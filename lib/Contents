```./emitter/Emitter.cpp
#include <string>
#include <random>
#include <any>
#include <iostream>
#include "Emitter.hpp"
#include <stdexcept>
#include <vector>
#include <memory>

Emitter::Emitter(std::vector<std::shared_ptr<ASTNode>>& program)
    : program(program) {}

std::vector<Bytecode> Emitter::emit() {
    std::vector<Bytecode> main; // .main entry code
    std::vector<Bytecode> structural; // passive code like definitions of functions, classes, etc
    main.push_back({OP_LABEL, {"main"}});

    for (const auto& node : program) {
        auto code = emit_node(node);
        for (auto b : code) {
            // std::cout << b.toString() << std::endl;
            if (node->type == ASTNodeType::FUNCTION_STMT ||
                node->type == ASTNodeType::NAMESPACE_DECL) {
                structural.push_back(b);
            } else {
                main.push_back(b);
            }
        }
    }

    main.push_back({OP_EXIT, {}});

    std::vector<Bytecode> result;
    result.insert(result.begin(), structural.begin(), structural.end());
    result.insert(result.end(), main.begin(), main.end());
    return result;
}

std::vector<Bytecode> Emitter::emit_node(const std::shared_ptr<ASTNode>& node) {
    switch (node->type) {
        case ASTNodeType::DECLARATION:
            return emit_declaration(std::static_pointer_cast<Declaration>(node));
        case ASTNodeType::LITERAL:
            return emit_literal(std::static_pointer_cast<Literal>(node));
        case ASTNodeType::BINARY_OP:
            return emit_binary_op(std::static_pointer_cast<BinaryOp>(node));
        case ASTNodeType::VARIABLE:
            return emit_variable(std::static_pointer_cast<Variable>(node));
        case ASTNodeType::IF_STMT:
            return emit_if_stmt(std::static_pointer_cast<IfStmt>(node));
        case ASTNodeType::META_STMT:
            return emit_meta_stmt(std::static_pointer_cast<MetaStmt>(node));
        case ASTNodeType::FUNCTION_STMT:
            return emit_function_stmt(std::static_pointer_cast<FunctionStmt>(node));
        case ASTNodeType::RETURN_STMT:
            return emit_return(std::static_pointer_cast<ReturnStmt>(node));
        case ASTNodeType::CALL_EXPR:
            return emit_call_expr(std::static_pointer_cast<CallExpr>(node));
        case ASTNodeType::EXPRESSION_STMT:
            return emit_expression_stmt(std::static_pointer_cast<ExpressionStmt>(node));
        case ASTNodeType::NAMESPACE_DECL:
            return emit_namespace(std::static_pointer_cast<Namespace>(node));
        case ASTNodeType::FIELD_ACCESS:
            return emit_field_access(std::static_pointer_cast<FieldAccess>(node));
        default:
            std::cout << ast_to_string(node) << std::endl;
            throw std::runtime_error("<unknown AST node type>");
    }
}

std::string random_identifier(size_t length = 12) {
    static const std::string chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789";
    static std::mt19937 rng(std::random_device{}());
    static std::uniform_int_distribution<> dist(0, chars.size() - 1);

    std::string result = "_";
    result.reserve(length);
    for (size_t i = 0; i < length - 1; ++i) {
        result += chars[dist(rng)];
    }
    return result;
}

std::vector<Bytecode> Emitter::emit_function_stmt(const std::shared_ptr<FunctionStmt>& funcStmt) {
    std::vector<Bytecode> code;

    // std::string ref_name = random_identifier();

    auto func_name = std::dynamic_pointer_cast<Variable>(funcStmt->name);

    // --- Function entry label ---
    code.push_back({ OP_LABEL, { func_name->name } });
    // code.push_back({ OP_JMP, { ref_name } });

    // // --- Function body label ---
    // code.push_back({ OP_LABEL, { ref_name } });

    // Emit function arguments
    for (auto p : funcStmt->params) {
        auto param = std::dynamic_pointer_cast<Variable>(p.first);
        auto type = std::dynamic_pointer_cast<Variable>(p.second);
        code.push_back({ OP_DECL, { "$" + param->name } });
        code.push_back({ OP_TYPE, { "$" + param->name, type->name } });
    }

    // Emit function body
    for (auto stmt : funcStmt->body) {
        auto stmt_code = emit_node(stmt);
        code.insert(code.end(), stmt_code.begin(), stmt_code.end());
    }

    // Function return
    code.push_back({ OP_RET, {} });
    code.push_back({ OP_END, {} });

    return code;
}

std::vector<Bytecode> Emitter::emit_return(const std::shared_ptr<ReturnStmt>& retStmt) {
    std::vector<Bytecode> code;

    if (retStmt->value.has_value()) {
        auto value = retStmt->value.value();
        auto value_code = emit_node(value);
        code.insert(code.end(), value_code.begin(), value_code.end());
    }

    code.push_back({ OP_RET, {} });

    return code;
}

std::vector<Bytecode> Emitter::emit_expression_stmt(const std::shared_ptr<ExpressionStmt>& exprStmt) {
    return emit_node(exprStmt->expression);
}

std::string resolve_field_access(const std::shared_ptr<ASTNode>& node) {
    if (!node) throw std::runtime_error("Cannot resolve null callee");

    switch (node->type) {
        case ASTNodeType::VARIABLE: {
            auto var = std::static_pointer_cast<Variable>(node);
            return var->name;
        }

        case ASTNodeType::FIELD_ACCESS: {
            auto field = std::static_pointer_cast<FieldAccess>(node);
            std::string base = resolve_field_access(field->object);
            auto prop = std::dynamic_pointer_cast<Variable>(field->field);
            if (!prop) {
                throw std::runtime_error("FieldAccess right-hand side must be Variable.");
            }
            return base + "." + prop->name;
        }

        default:
            throw std::runtime_error("Unsupported callee type in resolve_field_access");
    }
}


// std::vector<Bytecode> Emitter::emit_call_expr(const std::shared_ptr<CallExpr>& callExpr) {
//     std::vector<Bytecode> code;

//     auto callee = resolve_field_access(callExpr->callee);

//     // Push arguments RIGHT to LEFT
//     for (int i = callExpr->arguments.size() - 1; i >= 0; i--) {
//         auto b = emit_node(callExpr->arguments[i]);
//         code.insert(code.end(), b.begin(), b.end());
//     }

//     code.push_back({ OP_CALL, { callee } });
//     return code;
// }



// std::vector<Bytecode> Emitter::emit_field_access(const std::shared_ptr<FieldAccess>& fieldAccess) {
//     std::vector<Bytecode> code;

//     std::string full_name;
//     std::shared_ptr<ASTNode> current = fieldAccess;

//     // Collect field names in reverse order
//     std::vector<std::string> components;

//     // Walk the FieldAccess chain
//     while (auto field = std::dynamic_pointer_cast<FieldAccess>(current)) {
//         auto field_var = std::dynamic_pointer_cast<Variable>(field->field);
//         if (!field_var) {
//             throw std::runtime_error("FieldAccess::field must be Variable");
//         }
//         components.push_back(field_var->name);
//         current = field->object;
//     }

//     // Add base object
//     if (auto base = std::dynamic_pointer_cast<Variable>(current)) {
//         components.push_back(base->name);
//     } else {
//         throw std::runtime_error("FieldAccess::base must be Variable");
//     }

//     // Reverse and join
//     std::reverse(components.begin(), components.end());
//     std::string full_access = "$" + components[0];
//     for (size_t i = 1; i < components.size(); ++i) {
//         full_access += "." + components[i];
//     }

//     code.push_back(Bytecode{OP_GET, {full_access}});
//     return code;
// }

std::vector<Bytecode> Emitter::emit_call_expr(const std::shared_ptr<CallExpr>& call) {
    std::vector<Bytecode> code;

    // 1) emit the callee expression just once
    auto callee_code = emit_node(call->callee);
    code.insert(code.end(), callee_code.begin(), callee_code.end());

    // 2) push arguments rightâ†’left
    for (int i = int(call->arguments.size()) - 1; i >= 0; --i) {
        auto argCode = emit_node(call->arguments[i]);
        code.insert(code.end(), argCode.begin(), argCode.end());
    }

    // 3) generic call opcode
    code.push_back({ OP_CALL, {} });
    return code;
}

std::vector<Bytecode> Emitter::emit_field_access(const std::shared_ptr<FieldAccess>& fa) {
    std::vector<Bytecode> code;

    // 1) emit receiver, once
    auto receiver_code = emit_node(fa->object);
    code.insert(code.end(),
                receiver_code.begin(),
                receiver_code.end());

    // 2) turn the ASTNode field into its name
    auto var = std::dynamic_pointer_cast<Variable>(fa->field);
    if (!var) throw std::runtime_error("FieldAccess::field must be a Variable");
    std::string fieldName = var->name;

    // 3) push the field name as a literal string
    code.push_back({ OP_PUSH, { "\"" + fieldName + "\"" } });

    // 4) do the dynamic lookup
    code.push_back({ OP_ACCESS, {} });
    return code;
}

std::vector<Bytecode> Emitter::emit_namespace(const std::shared_ptr<Namespace>& ns) {
    std::vector<Bytecode> code;

    auto ns_name = std::dynamic_pointer_cast<Variable>(ns->name)->name;

    for (const auto& stmt : ns->body) {
        auto inner_code = emit_node(stmt);
        for (auto& bc : inner_code) {
            if (bc.opcode == OP_LABEL && !bc.operand.empty()) {
                // Prefix label with namespace
                bc.operand[0] = ns_name + "." + bc.operand[0];
            }
        }
        code.insert(code.end(), inner_code.begin(), inner_code.end());
    }
    return code;
}

std::vector<Bytecode> Emitter::emit_meta_stmt(const std::shared_ptr<MetaStmt>& metaStmt) {
    std::vector<Bytecode> code;

    // Correctly cast ASTNode -> Variable
    auto ns = std::dynamic_pointer_cast<Variable>(metaStmt->ns);
    if (!ns) {
        throw std::runtime_error("MetaStmt ns is not a Variable.");
    }

    auto callee_var = std::dynamic_pointer_cast<Variable>(metaStmt->call);
    if (!callee_var) {
        throw std::runtime_error("MetaStmt call is not a Variable.");
    }

    auto callee = callee_var->name;
    auto args = metaStmt->arg;

    // Functions
    if (args.has_value()) {
        if (callee == "Emit") {
            if (!args.has_value() || args->size() != 1) {
                throw std::runtime_error("Meta.Emit(...) expects exactly one argument. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            auto first_arg = args->at(0);
            auto lit = std::dynamic_pointer_cast<Literal>(first_arg);
            if (!lit) {
                throw std::runtime_error("Meta.Emit(...) expects a literal string argument.");
            }

            if (!lit->is_str()) {
                throw std::runtime_error("Meta.Emit(...) expects a single string argument.");
            }

            std::string raw_code = lit->value;
            str_decode(raw_code);
            std::vector<Bytecode> code = parse_raw_bytecode(raw_code);
            return code;
        }
        if (callee == "Time") {
            if (!args.has_value() || args->size() != 0) {
                throw std::runtime_error("Meta.Time() expects exactly zero arguments. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            std::vector<Bytecode> code = parse_raw_bytecode("(TIME)");
            return code;
        }
        if (callee == "Random") {
            if (!args.has_value() || args->size() != 0) {
                throw std::runtime_error("Meta.Random() expects exactly zero arguments. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            std::vector<Bytecode> code = parse_raw_bytecode("(RAND)");
            return code;
        }
        if (callee == "Pop") {
            // ensure variable passed as single parameter
            if (!args.has_value() || args->size() != 1) {
                throw std::runtime_error("Meta.Pop(...) expects exactly one argument. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            auto abstract_var = args.value().front();
            if (abstract_var->type != ASTNodeType::VARIABLE) {
                throw std::runtime_error("Meta.Pop(...) expects a variable argument. Given: " + (args ? std::to_string(static_cast<int>(abstract_var->type)) : "none"));
            }

            auto var = std::dynamic_pointer_cast<Variable>(abstract_var);
            std::vector<Bytecode> code = parse_raw_bytecode("(SET, $" + var->name + ")");
            return code;
        }
        if (callee == "Push") {
            // ensure variable passed as single parameter
            if (!args.has_value() || args->size() != 1) {
                throw std::runtime_error("Meta.Push(...) expects exactly one argument. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            auto abstract_var = args.value().front();
            if (abstract_var->type != ASTNodeType::VARIABLE) {
                throw std::runtime_error("Meta.Push(...) expects a variable argument. Given: " + (args ? std::to_string(static_cast<int>(abstract_var->type)) : "none"));
            }

            auto var = std::dynamic_pointer_cast<Variable>(abstract_var);
            std::vector<Bytecode> code = parse_raw_bytecode("(GET, $" + var->name + ")");
            return code;
        }
        if (callee == "Write") {
            if (!args.has_value() || args->size() != 0) {
                throw std::runtime_error("Meta.Write() expects exactly zero arguments. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            std::vector<Bytecode> code = parse_raw_bytecode("(WRITE)");
            return code;
        }
        if (callee == "WriteLine") {
            if (!args.has_value() || args->size() != 0) {
                throw std::runtime_error("Meta.WriteLine() expects exactly zero arguments. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            std::vector<Bytecode> code = parse_raw_bytecode("(PUSH, \"\\n\")\n(WRITE)");
            return code;
        }
        if (callee == "Flush") {
            if (!args.has_value() || args->size() != 0) {
                throw std::runtime_error("Meta.Flush() expects exactly zero arguments. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            std::vector<Bytecode> code = parse_raw_bytecode("(FLUSH)");
            return code;
        }
        if (callee == "Dump") {
            if (!args.has_value() || args->size() != 0) {
                throw std::runtime_error("Meta.Dump() expects exactly zero arguments. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            std::vector<Bytecode> code = parse_raw_bytecode("(DUMP)");
            return code;
        }
    }
    // Properties
    else {
        // Handle property access...
    }

    throw std::runtime_error("Unexpected Meta call: '" + callee + "'");
}

std::vector<Bytecode> Emitter::emit_if_stmt(const std::shared_ptr<IfStmt>& var) {
    std::vector<Bytecode> code;

    return code;
}

std::vector<Bytecode> Emitter::emit_variable(const std::shared_ptr<Variable>& var) {
    std::vector<Bytecode> code;
    code.push_back({ OP_GET, { "$" + var->name } });

    return code;
}

std::vector<Bytecode> Emitter::emit_binary_op(const std::shared_ptr<BinaryOp>& binop) {
    std::vector<Bytecode> code;
    Opcode o;
    if (binop->op == "+") {
        o = Opcode::OP_ADD;
    } else if (binop->op == "-") {
        o = Opcode::OP_SUB;
    } else if (binop->op == "*") {
        o = Opcode::OP_MUL;
    } else if (binop->op == "/") {
        o = Opcode::OP_DIV;
    } else if (binop->op == "%") {
        o = Opcode::OP_MOD;
    } else if (binop->op == "&&") {
        o = Opcode::OP_AND;
    } else if (binop->op == "||") {
        o = Opcode::OP_OR;
    }

    // left side
    auto left_code = emit_node(binop->left);
    code.insert(code.end(), left_code.begin(), left_code.end());

    // right side
    auto right_code = emit_node(binop->right);
    code.insert(code.end(), right_code.begin(), right_code.end());

    code.push_back(Bytecode{ o, {} });

    return code;
}

std::vector<Bytecode> Emitter::emit_literal(const std::shared_ptr<Literal>& literal) {
    std::vector<Bytecode> code;

    auto lit = static_cast<Literal*>(literal.get());
    std::string value = lit->value;
    if (lit->is_str()) {
        str_encode(value);
    }

    code.push_back({
        OP_PUSH,
        {value}
    });

    return code;
}

std::vector<Bytecode> Emitter::emit_declaration(const std::shared_ptr<Declaration>& decl) {
    std::vector<Bytecode> code;

    auto pattern = std::dynamic_pointer_cast<VariablePattern>(decl->pattern);
    if (!pattern) {
        throw std::runtime_error("Only simple variable declarations are supported for now.");
    }

    const std::string& name = pattern->name;
    std::string type = decl->type_annotation.value_or("Any");

    // Step 1: Declare the variable (before any value is assigned!)
    code.push_back(Bytecode{ OP_DECL, { "$" + name } });

    // Step 2: Annotate its type
    code.push_back(Bytecode{ OP_TYPE, { "$" + name, type } });

    // Step 3: If initializer exists, assign value into it
    if (decl->initializer.has_value()) {
        // 3a: emit code to compute the initializer
        auto init_code = emit_node(decl->initializer.value());
        code.insert(code.end(), init_code.begin(), init_code.end());

        // 3b: after computing, set it into variable
        code.push_back(Bytecode{ OP_SET, { "$" + name } });

        // 3c: cast to annotated type
        if (decl->type_annotation) {
          // push the ClassObject by name
          code.push_back({ OP_GET, { decl->type_annotation.value() } });
          // invoke it with 1 argument
          code.push_back({ OP_CALL, {} });
        }
    }

    return code;
}

# ```
# 

```./emitter/Emitter.hpp

#pragma once

#include <string>
#include <vector>
#include <memory>
#include "../vm/helpers/parse_raw_bytecode.hpp"
#include "../vm/helpers/str_decode.hpp"
#include "../vm/helpers/str_encode.hpp"
#include "../frontend/AST.hpp"
#include "../vm/core/Bytecode.hpp"

class Emitter {
public:
    std::vector<std::shared_ptr<ASTNode>>& program;
    Emitter(std::vector<std::shared_ptr<ASTNode>>& program);

    // Main entrypoint: emit bytecode for a full AST
    std::vector<Bytecode> emit();

private:
    std::vector<Bytecode> bytecode;
    std::vector<Bytecode> emit_node(const std::shared_ptr<ASTNode>& node);
    std::vector<Bytecode> emit_declaration(const std::shared_ptr<Declaration>& decl);
    std::vector<Bytecode> emit_expression_stmt(const std::shared_ptr<ExpressionStmt>& exprStmt);
    std::vector<Bytecode> emit_function_stmt(const std::shared_ptr<FunctionStmt>& funcStmt);
    std::vector<Bytecode> emit_assignment(const std::shared_ptr<Assignment>& assign);
    std::vector<Bytecode> emit_binary_op(const std::shared_ptr<BinaryOp>& binop);
    std::vector<Bytecode> emit_unary_op(const std::shared_ptr<UnaryOp>& unop);
    std::vector<Bytecode> emit_literal(const std::shared_ptr<Literal>& literal);
    std::vector<Bytecode> emit_variable(const std::shared_ptr<Variable>& variable);
    std::vector<Bytecode> emit_meta_stmt(const std::shared_ptr<MetaStmt>& metaStmt);
    std::vector<Bytecode> emit_call_expr(const std::shared_ptr<CallExpr>& callExpr);
    std::vector<Bytecode> emit_if_stmt(const std::shared_ptr<IfStmt>& ifStmt);
    std::vector<Bytecode> emit_return(const std::shared_ptr<ReturnStmt>& ret);
    std::vector<Bytecode> emit_namespace(const std::shared_ptr<Namespace>& ns);
    std::vector<Bytecode> emit_field_access(const std::shared_ptr<FieldAccess>& fieldAccess);
};

std::string resolve_field_access(const std::shared_ptr<ASTNode>& callee);

# ```
# 

```./frontend/TokenType.hpp
#pragma once

enum TokenType {
    // --- Literals
    TOK_INTEGER,     // 123
    TOK_DECIMAL,     // 3.14
    TOK_STRING,      // "hello"

    // --- Identifiers / Keywords
    TOK_IDENTIFIER,  // x, foo, myVar
    TOK_KEYWORD,     // let, if, else, return,

    // --- Operators
    TOK_PLUS,        // +
    TOK_MINUS,       // -
    TOK_ASTERISK,    // *
    TOK_SLASH,       // /
    TOK_PERCENT,     // %

    TOK_EQUAL,       // ==
    TOK_NOT_EQUAL,   // !=
    TOK_LESS,        // <
    TOK_LESS_EQUAL,  // <=
    TOK_GREATER,     // >
    TOK_GREATER_EQUAL, // >=

    TOK_ASSIGN,      // =

    TOK_AND,         // &&
    TOK_OR,          // ||
    TOK_NOT,         // !

    // --- Symbols
    TOK_LPAREN,      // (
    TOK_RPAREN,      // )
    TOK_LBRACKET,    // [
    TOK_RBRACKET,    // ]
    TOK_LBRACE,      // {
    TOK_RBRACE,      // }
    TOK_COMMA,       // ,
    TOK_DOT,         // .
    TOK_COLON,       // :
    TOK_SEMICOLON,   // ;

    // --- Special
    TOK_EOF,         // End of file/input
    TOK_UNKNOWN      // Invalid/unknown character
};

# ```
# 

```./frontend/match_keyword.cpp
#include "match_keyword.hpp"
std::optional<Keyword> match_keyword(const std::string& word) {
    if (word == "let")          return KW_LET;
    if (word == "if")           return KW_IF;
    if (word == "elif")         return KW_ELIF;
    if (word == "else")         return KW_ELSE;
    if (word == "while")        return KW_WHILE;
    if (word == "Meta")         return KW_META;
    if (word == "guard")        return KW_GUARD;
    if (word == "for")          return KW_FOR;
    if (word == "in")           return KW_IN;
    if (word == "break")        return KW_BREAK;
    if (word == "continue")     return KW_CONTINUE;
    if (word == "return")       return KW_RETURN;
    if (word == "func")         return KW_FUNC;
    if (word == "fn")           return KW_FN;
    if (word == "lambda")       return KW_LAMBDA;
    if (word == "struct")       return KW_STRUCT;
    if (word == "import")       return KW_IMPORT;
    if (word == "export")       return KW_EXPORT;
    if (word == "as")           return KW_AS;
    if (word == "match")        return KW_MATCH;
    if (word == "case")         return KW_CASE;
    if (word == "default")      return KW_DEFAULT;
    if (word == "true")         return KW_TRUE;
    if (word == "false")        return KW_FALSE;
    if (word == "nil")          return KW_NIL;
    if (word == "nix")          return KW_NIX;
    if (word == "nan")          return KW_NAN;
    if (word == "namespace")    return KW_NAMESPACE;
    return std::nullopt;
}

# ```
# 

```./frontend/Keyword.hpp
#pragma once

enum Keyword {
    KW_LET,             // variable declaration
    KW_IF,              // if block
    KW_ELIF,            // else-if block
    KW_ELSE,            // else block
    KW_GUARD,           // guard block
    KW_WHILE,           // while loop
    KW_FOR,             // for loop
    KW_IN,              // for ... in ...
    KW_BREAK,           // break out of loop
    KW_CONTINUE,        // continue loop
    KW_RETURN,          // return from function
    KW_META,            // Meta keyword
    KW_FN,              // inline-function declaration
    KW_LAMBDA,          // lambda-function declaration
    KW_FUNC,            // function declaration
    KW_NAMESPACE,       // namespace declaration
    KW_STRUCT,          // struct declaration
    KW_IMPORT,          // import modules
    KW_EXPORT,          // export functions/types
    KW_AS,              // rename imports
    KW_MATCH,           // pattern matching (like switch)
    KW_CASE,            // case branch inside match
    KW_DEFAULT,         // default branch inside match
    KW_TRUE,            // literal true
    KW_FALSE,           // literal false
    KW_NIL,             // literal nil
    KW_NIX,             // literal nil
    KW_NAN,             // literal nil
    KW_TRY,             // try block
    KW_CATCH,           // catch block
    KW_THROW,           // throw an error
    KW_DEFER,           // run after scope exit (golang-style)
    KW_TYPE,            // user-defined type (aliasing)
};

# ```
# 

```./frontend/Desugarer.cpp
#include "Desugarer.hpp"
#include "AST.hpp"

Desugarer::Desugarer(std::vector<std::shared_ptr<ASTNode>>& ast) : ast(ast) {};

std::vector<std::shared_ptr<ASTNode>> Desugarer::desugar() {
    std::vector<std::shared_ptr<ASTNode>> result;
    for (const auto& node : ast) {
        result.push_back(desugar_node(node));
    }
    return result;
}

std::shared_ptr<ASTNode> Desugarer::desugar_node(std::shared_ptr<ASTNode> node) {
    if (!node) return nullptr;

    switch (node->type) {
        // case ASTNodeType::DECLARATION:
        //     return desugar_declaration(std::static_pointer_cast<Declaration>(node));
        // case ASTNodeType::ASSIGNMENT:
        //     return desugar_assignment(std::static_pointer_cast<Assignment>(node));
        // case ASTNodeType::EXPRESSION_STMT:
        //     return desugar_expression_stmt(std::static_pointer_cast<ExpressionStmt>(node));
        // case ASTNodeType::IF_STMT:
        //     return desugar_if_stmt(std::static_pointer_cast<IfStmt>(node));
        case ASTNodeType::GUARD_STMT:
            return desugar_guard_stmt(std::static_pointer_cast<GuardStmt>(node));
        // case ASTNodeType::WHILE_STMT:
        //     return desugar_while_stmt(std::static_pointer_cast<WhileStmt>(node));
        // case ASTNodeType::BLOCK_STMT:
        //     return desugar_block_stmt(std::static_pointer_cast<BlockStmt>(node));
        case ASTNodeType::FUNCTION_STMT:
            return desugar_func_decl(std::static_pointer_cast<FunctionStmt>(node));
        // case ASTNodeType::RETURN_STMT:
        //     return desugar_return_stmt(std::static_pointer_cast<ReturnStmt>(node));
        // case ASTNodeType::STRUCT_DECL:
        //     return desugar_struct_decl(std::static_pointer_cast<StructDecl>(node));
        // case ASTNodeType::IMPORT_DECL:
        //     return desugar_import_decl(std::static_pointer_cast<ImportDecl>(node));
        // case ASTNodeType::CALL_EXPR:
        //     return desugar_call_expr(std::static_pointer_cast<CallExpr>(node));
        default:
            // For things like literals, variables, binary ops, just return as is
            return node;
    }
}

// --- Individual desugar methods ---

std::shared_ptr<ASTNode> Desugarer::desugar_declaration(std::shared_ptr<Declaration> decl) {
    // TODO: handle destructuring, multiple vars, chained assignment, etc.
    return decl;
}

std::shared_ptr<ASTNode> Desugarer::desugar_assignment(std::shared_ptr<Assignment> assign) {
    // TODO: handle chained assignment: x = y = z = 5;
    return assign;
}

std::shared_ptr<ASTNode> Desugarer::desugar_expression_stmt(std::shared_ptr<ExpressionStmt> expr_stmt) {
    expr_stmt->expression = desugar_node(expr_stmt->expression);
    return expr_stmt;
}

std::shared_ptr<ASTNode> Desugarer::desugar_if_stmt(std::shared_ptr<IfStmt> if_stmt) {
    // if_stmt->condition = desugar_node(if_stmt->condition);
    // if_stmt->thenBranch = desugar_node(if_stmt->thenBranch);
    // if (if_stmt->elseBranch.has_value()) {
    //     if_stmt->elseBranch = desugar_node(if_stmt->elseBranch.value());
    // }
    return if_stmt;
}

std::shared_ptr<ASTNode> Desugarer::desugar_guard_stmt(std::shared_ptr<GuardStmt> guard_stmt) {
    // Build a NOT(cond) expression
    auto not_condition = std::make_shared<UnaryOp>("!", desugar_node(guard_stmt->condition));

    auto else_branch = desugar_node(guard_stmt->elseBranch);

    return std::make_shared<IfStmt>(
        not_condition,
        else_branch
    );
}

std::shared_ptr<ASTNode> Desugarer::desugar_while_stmt(std::shared_ptr<WhileStmt> while_stmt) {
    // while_stmt->condition = desugar_node(while_stmt->condition);
    // while_stmt->body = desugar_node(while_stmt->body);
    return while_stmt;
}

std::shared_ptr<ASTNode> Desugarer::desugar_block_stmt(std::shared_ptr<BlockStmt> block_stmt) {
    // std::vector<std::shared_ptr<ASTNode>> new_statements;
    // for (auto& stmt : block_stmt->statements) {
    //     new_statements.push_back(desugar_node(stmt));
    // }
    // block_stmt->statements = std::move(new_statements);
    return block_stmt;
}

std::shared_ptr<ASTNode> Desugarer::desugar_func_decl(std::shared_ptr<FunctionStmt> func_decl) {
    for (int i = 0; i < func_decl->body.size(); i++) {
        func_decl->body.at(i) = desugar_node(func_decl->body.at(i));
    }

    return func_decl;
}

std::shared_ptr<ASTNode> Desugarer::desugar_return_stmt(std::shared_ptr<ReturnStmt> return_stmt) {
    if (return_stmt->value.has_value()) {
        return_stmt->value = desugar_node(return_stmt->value.value());
    } else {
        return_stmt->value = std::make_shared<Literal>("nil");
    }

    return return_stmt;
}

std::shared_ptr<ASTNode> Desugarer::desugar_struct_decl(std::shared_ptr<StructDecl> struct_decl) {
    // Usually nothing to desugar here yet
    return struct_decl;
}

std::shared_ptr<ASTNode> Desugarer::desugar_import_decl(std::shared_ptr<ImportDecl> import_decl) {
    // Nothing to desugar
    return import_decl;
}

std::shared_ptr<ASTNode> Desugarer::desugar_call_expr(std::shared_ptr<CallExpr> call_expr) {
    // call_expr->callee = desugar_node(call_expr->callee);
    // for (auto& arg : call_expr->arguments) {
    //     arg = desugar_node(arg);
    // }
    return call_expr;
}

// --- Utility ---

std::shared_ptr<BlockStmt> Desugarer::flatten(const std::vector<std::shared_ptr<ASTNode>>& stmts) {
    return std::make_shared<BlockStmt>(stmts);
}

# ```
# 

```./frontend/Parser.hpp
#pragma once
#include <vector>
#include <optional>
#include <memory>
#include "Token.hpp"
#include "TokenType.hpp"
#include "Keyword.hpp"
#include "AST.hpp" // (you'll define the ASTNode, Assignment, BinaryOp, etc.)

class Parser {
public:
    explicit Parser(const std::vector<Token>& tokens);

    std::vector<std::shared_ptr<ASTNode>> parse();

private:
    const std::vector<Token>& tokens;
    size_t current = 0;

    // Core helpers
    bool at_end() const;
    const Token& advance();
    const Token& peek() const;
    const Token& previous() const;
    bool match(std::initializer_list<TokenType> types);
    bool check(TokenType type) const;
    std::vector<Token> collect_until_keyword_or(TokenType stop, const std::string& keyword);
    std::shared_ptr<ASTNode> parse_head(const std::vector<Token>& head_tokens);
    std::shared_ptr<BlockStmt> parse_block();
    std::shared_ptr<ASTNode> parse_call(std::shared_ptr<ASTNode> callee);

    void synchronize(); // error recovery (optional later)

    // Parsing functions
    std::shared_ptr<ASTNode> parse_statement();
    std::shared_ptr<ASTNode> parse_expression();
    std::shared_ptr<ASTNode> parse_assignment();
    std::shared_ptr<ASTNode> parse_term();
    std::shared_ptr<ASTNode> parse_factor();
    std::shared_ptr<ASTNode> parse_primary();
    std::shared_ptr<ASTNode> parse_or();
    std::shared_ptr<ASTNode> parse_and();
    std::shared_ptr<ASTNode> parse_equality();
    std::shared_ptr<ASTNode> parse_comparison();
    std::shared_ptr<ASTNode> parse_unary();

    // Specific statement parsers
    std::shared_ptr<ASTNode> parse_let();
    std::shared_ptr<ASTNode> parse_for();
    std::shared_ptr<ASTNode> parse_return();
    std::shared_ptr<ASTNode> parse_meta();
    std::shared_ptr<ASTNode> parse_guard();
    std::shared_ptr<ASTNode> parse_function();
    std::shared_ptr<ASTNode> parse_namespace();

    // Utilities
    std::shared_ptr<BlockStmt> parse_block_already_open();
    std::shared_ptr<BlockStmt> parse_block_no_open();
    Token consume(TokenType type, const std::string& error_message);
};

# ```
# 

```./frontend/AST.cpp
#include "AST.hpp"
#include <string>

// --- ASTNode Destructor ---
ASTNode::~ASTNode() {}

// --- Literal Constructor ---
Literal::Literal(const std::string& val) : value(val) {
    type = ASTNodeType::LITERAL;
}
bool Literal::is_str() {
    return value.starts_with('"') && value.ends_with('"');
}
bool Literal::is_dec() {
    throw "not impl.";
}
bool Literal::is_int() {
    throw "not impl.";
}

// --- Variable Constructor ---
Variable::Variable(const std::string& n) : name(n) {
    type = ASTNodeType::VARIABLE;
}

// --- Namespace Reference Node ---
Namespace::Namespace(const std::shared_ptr<ASTNode> n, std::vector<std::shared_ptr<ASTNode>> body)
    : name(n), body(std::move(body)) {
    type = ASTNodeType::NAMESPACE_DECL;
}

// --- BinaryOp Constructor ---
BinaryOp::BinaryOp(const std::string& oper, std::shared_ptr<ASTNode> lhs, std::shared_ptr<ASTNode> rhs)
    : op(oper), left(std::move(lhs)), right(std::move(rhs)) {
    type = ASTNodeType::BINARY_OP;
}

// --- UnaryOp Constructor ---
UnaryOp::UnaryOp(const std::string& oper, std::shared_ptr<ASTNode> opd)
    : op(oper), operand(std::move(opd)) {
    type = ASTNodeType::UNARY_OP;
}

// --- Declaration Constructor ---
Declaration::Declaration(std::shared_ptr<ASTNode> pat,
                         std::optional<std::string> typeAnn,
                         std::optional<std::shared_ptr<ASTNode>> init)
    : pattern(std::move(pat)),
      type_annotation(std::move(typeAnn)),
      initializer(std::move(init)) {
    type = ASTNodeType::DECLARATION;
}

// --- Field Access Constructor ---
FieldAccess::FieldAccess(std::shared_ptr<ASTNode> object, std::shared_ptr<ASTNode> field)
    : object(std::move(object)), field(std::move(field)) {
    type = ASTNodeType::FIELD_ACCESS;
}

// --- VariablePattern Constructor ---
VariablePattern::VariablePattern(const std::string& n)
    : name(n) {
    type = ASTNodeType::VARIABLE_PATTERN;
}

// --- TuplePattern Constructor ---
TuplePattern::TuplePattern(std::vector<std::string> n)
    : names(std::move(n)) {
    type = ASTNodeType::TUPLE_PATTERN;
}

// --- DestructurePattern Constructor ---
DestructurePattern::DestructurePattern(std::vector<std::string> n, bool isArr)
    : names(std::move(n)), isArray(isArr) {
    type = ASTNodeType::DESTRUCTURE_PATTERN;
}

// --- Assignment Constructor ---
Assignment::Assignment(const std::string& n, std::shared_ptr<ASTNode> val)
    : name(n), value(std::move(val)) {
    type = ASTNodeType::ASSIGNMENT;
}

// --- ExpressionStmt Constructor ---
ExpressionStmt::ExpressionStmt(std::shared_ptr<ASTNode> expr) : expression(std::move(expr)) {
    type = ASTNodeType::EXPRESSION_STMT;
}

// --- MetaStmt Constructor ---
MetaStmt::MetaStmt(
    std::shared_ptr<ASTNode> ns,
    std::shared_ptr<ASTNode> call,
    std::optional<std::vector<std::shared_ptr<ASTNode>>> arg
)
    : ns(std::move(ns)), call(std::move(call)), arg(std::move(arg)) {
    type = ASTNodeType::META_STMT;
}

MetaStmt::MetaStmt(
    std::shared_ptr<ASTNode> ns,
    std::shared_ptr<ASTNode> call
)
    : ns(std::move(ns)), call(std::move(call)) {
    type = ASTNodeType::META_STMT;
}

// --- IfStmt Constructor ---
IfStmt::IfStmt(std::shared_ptr<ASTNode> cond, std::shared_ptr<ASTNode> thenB, std::vector<std::shared_ptr<ASTNode>> elifB, std::optional<std::shared_ptr<ASTNode>> elseB)
    : condition(std::move(cond)), thenBranch(std::move(thenB)), elifBranches(elifB), elseBranch(std::move(elseB)) {
    type = ASTNodeType::IF_STMT;
}

// --- GuardStmt Constructor ---
GuardStmt::GuardStmt(std::shared_ptr<ASTNode> cond, std::shared_ptr<ASTNode> elseB)
    : condition(std::move(cond)), elseBranch(std::move(elseB)) {
    type = ASTNodeType::GUARD_STMT;
}

// --- WhileStmt Constructor ---
WhileStmt::WhileStmt(std::shared_ptr<ASTNode> cond, std::shared_ptr<ASTNode> b)
    : condition(std::move(cond)), body(std::move(b)) {
    type = ASTNodeType::WHILE_STMT;
}

// --- ForInStmt Constructor ---
ForInStmt::ForInStmt(const std::string& n, std::shared_ptr<ASTNode> iter, std::shared_ptr<ASTNode> b)
    : varName(n), iterable(std::move(iter)), body(std::move(b)) {
    type = ASTNodeType::FOR_IN_STMT;
}

// --- BlockStmt Constructor ---
BlockStmt::BlockStmt(std::vector<std::shared_ptr<ASTNode>> stmts) : statements(std::move(stmts)) {
    type = ASTNodeType::BLOCK_STMT;
}

// --- FuncDecl Constructor ---
FunctionStmt::FunctionStmt(
    std::shared_ptr<ASTNode> name,
    std::vector<std::pair<std::shared_ptr<ASTNode>, std::shared_ptr<ASTNode>>> params,
    std::optional<std::shared_ptr<ASTNode>> returnType,
    std::vector<std::shared_ptr<ASTNode>> body
)
: name(name), params(params), returnType(returnType), body(body)
{
    type = ASTNodeType::FUNCTION_STMT;
}

// --- CallExpr Constructor ---
CallExpr::CallExpr(std::shared_ptr<ASTNode> c, std::vector<std::shared_ptr<ASTNode>> args)
    : callee(std::move(c)), arguments(std::move(args)) {
    type = ASTNodeType::CALL_EXPR;
}

// --- ReturnStmt Constructor ---
ReturnStmt::ReturnStmt(std::optional<std::shared_ptr<ASTNode>> v) : value(std::move(v)) {
    type = ASTNodeType::RETURN_STMT;
}

// --- StructDecl Constructor ---
StructDecl::StructDecl(const std::string& n, std::vector<std::string> f)
    : name(n), fields(std::move(f)) {
    type = ASTNodeType::STRUCT_DECL;
}

// --- ImportDecl Constructor ---
ImportDecl::ImportDecl(const std::string& m, std::optional<std::string> a)
    : module(m), alias(std::move(a)) {
    type = ASTNodeType::IMPORT_DECL;
}

std::string ast_to_string(const std::shared_ptr<ASTNode>& node) {
    if (!node) return "<null>";

    switch (node->type) {
        case ASTNodeType::LITERAL:
            return "Literal(" + static_cast<Literal*>(node.get())->value + ")";
        case ASTNodeType::VARIABLE:
            return "Variable(" + static_cast<Variable*>(node.get())->name + ")";
        case ASTNodeType::BINARY_OP: {
            auto bin = static_cast<BinaryOp*>(node.get());
            return "BinaryOp(" + bin->op + ", " + ast_to_string(bin->left) + ", " + ast_to_string(bin->right) + ")";
        }
        case ASTNodeType::UNARY_OP: {
            auto un = static_cast<UnaryOp*>(node.get());
            return "UnaryOp(" + un->op + ", " + ast_to_string(un->operand) + ")";
        }
        case ASTNodeType::DECLARATION: {
            auto decl = static_cast<Declaration*>(node.get());
            std::string out = "Declaration(";
            out += ast_to_string(decl->pattern);
            if (decl->type_annotation) {
                out += ": " + decl->type_annotation.value();
            }
            if (decl->initializer) {
                out += " = " + ast_to_string(decl->initializer.value());
            }
            out += ")";
            return out;
        }
        case ASTNodeType::VARIABLE_PATTERN: {
            auto p = static_cast<VariablePattern*>(node.get());
            return "VariablePattern(" + p->name + ")";
        }
        case ASTNodeType::TUPLE_PATTERN: {
            auto p = static_cast<TuplePattern*>(node.get());
            std::string result = "TuplePattern(";
            for (size_t i = 0; i < p->names.size(); ++i) {
                result += p->names[i];
                if (i + 1 < p->names.size()) result += ", ";
            }
            result += ")";
            return result;
        }
        case ASTNodeType::DESTRUCTURE_PATTERN: {
            auto p = static_cast<DestructurePattern*>(node.get());
            std::string result = (p->isArray ? "ArrayDestructure(" : "ObjectDestructure(");
            for (size_t i = 0; i < p->names.size(); ++i) {
                result += p->names[i];
                if (i + 1 < p->names.size()) result += ", ";
            }
            result += ")";
            return result;
        }
        case ASTNodeType::ASSIGNMENT: {
            auto assign = static_cast<Assignment*>(node.get());
            return "Assignment(" + assign->name + ", " + ast_to_string(assign->value) + ")";
        }
        case ASTNodeType::EXPRESSION_STMT: {
            auto expr = static_cast<ExpressionStmt*>(node.get());
            return "ExpressionStmt(" + ast_to_string(expr->expression) + ")";
        }
        case ASTNodeType::GUARD_STMT: {
            auto expr = static_cast<GuardStmt*>(node.get());
            return "GuardStmt(" + ast_to_string(expr->condition) + ", " + ast_to_string(expr->elseBranch) + ")";
        }
        case ASTNodeType::RETURN_STMT: {
            auto expr = static_cast<ReturnStmt*>(node.get());
            std::string v;
            if (expr->value) {
                v = ast_to_string(expr->value.value());
            }
            return "ReturnStmt(" + v + ")";
        }
        case ASTNodeType::BLOCK_STMT: {
            auto expr = static_cast<BlockStmt*>(node.get());

            std::string o = "";
            for (auto stmt : expr->statements) {
                o += ast_to_string(stmt);
            }
            return "BlockStmt(" + o + ")";
        }
        case ASTNodeType::IF_STMT: {
            auto expr = static_cast<IfStmt*>(node.get());
            return "IfStmt(" + ast_to_string(expr->condition) + ", " + ast_to_string(expr->thenBranch) + ")";
        }
        case ASTNodeType::FUNCTION_STMT: {
            auto expr = static_cast<FunctionStmt*>(node.get());
            std::string p = "";
            for (auto stmt : expr->params) {
                p += ast_to_string(stmt.first) + ": " + ast_to_string(stmt.second);
            }

            std::string c = "";
            for (auto stmt : expr->body) {
                c += ast_to_string(stmt) + "; ";
            }

            std::string ret = ast_to_string(expr->returnType.value_or(std::make_shared<ASTNode>(Variable("Any"))));

            return "FuncStmt(" + ast_to_string(expr->name) + ", (" + p + "), " + ret + ", {" + c + "})";
        }
        case ASTNodeType::CALL_EXPR: {
            auto expr = static_cast<CallExpr*>(node.get());
            std::string args = "";
            for (auto arg : expr->arguments) {
                args += ast_to_string(arg) + ", ";
            }
            return "CallExpr(" + ast_to_string(expr->callee) + ", (" + args + "))";
        }
        case ASTNodeType::META_STMT: {
            auto expr = static_cast<MetaStmt*>(node.get());
            std::string args = "";
            if (expr->arg.has_value()) {
                for (auto arg : expr->arg.value()) {
                    args += ast_to_string(arg) + ", ";
                }
            }

            return "MetaStmt(" + ast_to_string(expr->ns) + ", " + ast_to_string(expr->call) + ", (" + args + "))";
        }
        case ASTNodeType::NAMESPACE_DECL: {
            auto ns = static_cast<Namespace*>(node.get());
            std::string body = "";
            for (auto stmt : ns->body) {
                body += ast_to_string(stmt) + "; ";
            }

            return "NamespaceStmt(" + ast_to_string(ns->name) + ", (" + body + "))";
        }
        case ASTNodeType::FIELD_ACCESS: {
            auto expr = static_cast<FieldAccess*>(node.get());

            return "FieldAccess(" + ast_to_string(expr->object) + ", " + ast_to_string(expr->field) + ")";
        }
        default:
            return "<unhandled node type '" + std::to_string(static_cast<int>(node->type)) + "'>";
    }
}

# ```
# 

```./frontend/Token.hpp
#pragma once
#include <string>
#include <optional>
#include "Keyword.hpp"
#include "TokenType.hpp"

struct Token {
    std::string     lexeme  ;
    size_t          idx     ; // starting index
    TokenType       type    ;
    std::optional<Keyword> keyword; // Only used if type == TOK_KEYWORD
};

# ```
# 

```./frontend/Lexer.cpp
// lexer.cpp
#include "Lexer.hpp"
#include "TokenType.hpp"
#include "Token.hpp"
#include "match_keyword.hpp"

#include <cctype>
#include <optional>

Lexer::Lexer(const std::string& src)
    : source(src), current(0), start(0), length(src.size())
{}

std::vector<Token> Lexer::tokenize() {
    tokens.clear();
    while (!at_end()) {
        start = current;
        scan_token();
    }
    // EOF token
    tokens.push_back(Token{"", current, TOK_EOF, std::nullopt});
    return tokens;
}

bool Lexer::at_end() const {
    return current >= length;
}

char Lexer::advance() {
    return source[current++];
}

char Lexer::peek() const {
    return at_end() ? '\0' : source[current];
}

char Lexer::peek_next() const {
    return (current + 1 >= length) ? '\0' : source[current + 1];
}

bool Lexer::match(char expected) {
    if (at_end() || source[current] != expected) return false;
    current++;
    return true;
}

void Lexer::add_token(TokenType type) {
    add_token(type, source.substr(start, current - start));
}

void Lexer::add_token(TokenType type, const std::string& text) {
    tokens.push_back(Token{text, start, type, std::nullopt});
}

void Lexer::add_keyword_or_identifier() {
    std::string text = source.substr(start, current - start);
    if (auto kw = match_keyword(text)) {
        tokens.push_back(Token{text, start, TOK_KEYWORD, *kw});
    } else {
        tokens.push_back(Token{text, start, TOK_IDENTIFIER, std::nullopt});
    }
}

void Lexer::scan_token() {
    char c = advance();
    switch (c) {
        // Single-character tokens
        case '+': add_token(TOK_PLUS);        break;
        case '-': add_token(TOK_MINUS);       break;
        case '*': add_token(TOK_ASTERISK);    break;
        case '/':
            if (match('/')) {
                // skip comment until end of line
                while (peek() != '\n' && !at_end()) advance();
            } else {
                add_token(TOK_SLASH);
            }
            break;
        case '%': add_token(TOK_PERCENT);     break;
        case '(': add_token(TOK_LPAREN);      break;
        case ')': add_token(TOK_RPAREN);      break;
        case '[': add_token(TOK_LBRACKET);      break;
        case ']': add_token(TOK_RBRACKET);      break;
        case '{': add_token(TOK_LBRACE);      break;
        case '}': add_token(TOK_RBRACE);      break;
        case ',': add_token(TOK_COMMA);       break;
        case '.': add_token(TOK_DOT);         break;
        case ';': add_token(TOK_SEMICOLON);   break;
        case ':': add_token(TOK_COLON);   break;

        // One or two character tokens
        case '=': add_token(match('=') ? TOK_EQUAL         : TOK_ASSIGN);       break;
        case '!': add_token(match('=') ? TOK_NOT_EQUAL     : TOK_NOT);          break;
        case '<': add_token(match('=') ? TOK_LESS_EQUAL    : TOK_LESS);         break;
        case '>': add_token(match('=') ? TOK_GREATER_EQUAL : TOK_GREATER);      break;
        case '&': add_token(match('&') ? TOK_AND           : TOK_UNKNOWN);      break;
        case '|': add_token(match('|') ? TOK_OR            : TOK_UNKNOWN);      break;

        // Whitespace
        case ' ':
        case '\r':
        case '\t':
        case '\n':
            break; // skip

        // String literals
        case '"': string();  break;

        default:
            if (std::isdigit(c)) {
                number();
            } else if (std::isalpha(c) || c == '_') {
                identifier();
            } else {
                add_token(TOK_UNKNOWN);
            }
    }
}

void Lexer::string() {
    // consume until closing quote
    while (peek() != '"' && !at_end()) {
        if (peek() == '\\' && peek_next() != '\0') {
            // skip escape sequence
            advance();
        }
        advance();
    }

    if (at_end()) {
        // Unterminated string; still emit what we have
        add_token(TOK_STRING);
        return;
    }

    // closing "
    advance();
    add_token(TOK_STRING, source.substr(start, current - start));
}

void Lexer::number() {
    // integer part
    while (std::isdigit(peek())) advance();

    // fractional part
    if (peek() == '.' && std::isdigit(peek_next())) {
        advance(); // consume '.'
        while (std::isdigit(peek())) advance();
        add_token(TOK_DECIMAL);
    } else {
        add_token(TOK_INTEGER);
    }
}

void Lexer::identifier() {
    while (std::isalnum(peek()) || peek() == '_') {
        advance();
    }
    add_keyword_or_identifier();
}

# ```
# 

```./frontend/Lexer.hpp
#pragma once
#include <string>
#include <vector>
#include "Keyword.hpp"
#include "match_keyword.hpp"
#include "Token.hpp"

class Lexer {
public:
    explicit Lexer(const std::string& src);

    std::vector<Token> tokenize();

private:
    const std::string& source;
    size_t current = 0;
    size_t start   = 0;
    size_t length  = 0;

    std::vector<Token> tokens;

    // --- Core advancing functions
    bool at_end() const;
    char advance();
    char peek() const;
    char peek_next() const;
    bool match(char expected);

    // --- Token creation
    void add_token(TokenType type);
    void add_token(TokenType type, const std::string& text);
    void add_keyword_or_identifier();

    // --- Handlers
    void scan_token();
    void string();
    void number();
    void identifier();
};

# ```
# 

```./frontend/match_keyword.hpp
#pragma once
#include <string>
#include <optional>
#include "Keyword.hpp"

std::optional<Keyword> match_keyword(const std::string& word);

# ```
# 

```./frontend/Desugarer.hpp
#pragma once
#include <vector>
#include <memory>
#include "AST.hpp"

// The Desugarer rewrites complex AST nodes into simpler forms
class Desugarer {
public:
    std::vector<std::shared_ptr<ASTNode>>& ast;
    Desugarer(std::vector<std::shared_ptr<ASTNode>>& ast);
    std::vector<std::shared_ptr<ASTNode>> desugar();

private:
    // Internal recursive helpers
    static std::shared_ptr<ASTNode> desugar_node(std::shared_ptr<ASTNode> node);

    static std::shared_ptr<ASTNode> desugar_declaration(std::shared_ptr<Declaration> decl);
    static std::shared_ptr<ASTNode> desugar_assignment(std::shared_ptr<Assignment> assign);
    static std::shared_ptr<ASTNode> desugar_expression_stmt(std::shared_ptr<ExpressionStmt> expr_stmt);
    static std::shared_ptr<ASTNode> desugar_if_stmt(std::shared_ptr<IfStmt> if_stmt);
    static std::shared_ptr<ASTNode> desugar_guard_stmt(std::shared_ptr<GuardStmt> guard_stmt);
    static std::shared_ptr<ASTNode> desugar_while_stmt(std::shared_ptr<WhileStmt> while_stmt);
    static std::shared_ptr<ASTNode> desugar_block_stmt(std::shared_ptr<BlockStmt> block_stmt);
    static std::shared_ptr<ASTNode> desugar_func_decl(std::shared_ptr<FunctionStmt> func_decl);
    static std::shared_ptr<ASTNode> desugar_return_stmt(std::shared_ptr<ReturnStmt> return_stmt);
    static std::shared_ptr<ASTNode> desugar_struct_decl(std::shared_ptr<StructDecl> struct_decl);
    static std::shared_ptr<ASTNode> desugar_import_decl(std::shared_ptr<ImportDecl> import_decl);
    static std::shared_ptr<ASTNode> desugar_call_expr(std::shared_ptr<CallExpr> call_expr);

    // Utility: flatten multiple statements into a block
    static std::shared_ptr<BlockStmt> flatten(const std::vector<std::shared_ptr<ASTNode>>& stmts);
};

# ```
# 

```./frontend/Parser.cpp
#include <iostream>
#include "Parser.hpp"
#include "AST.hpp"
#include "TokenType.hpp"
#include <memory>
#include <optional>
#include <stdexcept>

Parser::Parser(const std::vector<Token>& tokens)
    : tokens(tokens), current(0) {}

std::vector<std::shared_ptr<ASTNode>> Parser::parse() {
    std::vector<std::shared_ptr<ASTNode>> statements;
    while (!at_end()) {
        statements.push_back(parse_statement());
    }
    return statements;
}

bool Parser::at_end() const {
    return peek().type == TOK_EOF;
}

const Token& Parser::peek() const {
    return tokens[current];
}

const Token& Parser::previous() const {
    return tokens[current - 1];
}

const Token& Parser::advance() {
    if (!at_end()) current++;
    return previous();
}

bool Parser::check(TokenType type) const {
    if (at_end()) return false;
    return peek().type == type;
}

bool Parser::match(std::initializer_list<TokenType> types) {
    for (auto t : types) {
        if (check(t)) {
            advance();
            return true;
        }
    }
    return false;
}

Token Parser::consume(TokenType type, const std::string& error_message) {
    if (check(type)) return advance();
    throw std::runtime_error(error_message);
}

void Parser::synchronize() {
    while (!at_end() && peek().type != TOK_SEMICOLON) {
        advance();
    }
    if (check(TOK_SEMICOLON)) advance();
}

std::shared_ptr<BlockStmt> Parser::parse_block() {
    consume(TOK_LBRACE, "Expected '{' in parse_block");
    std::vector<std::shared_ptr<ASTNode>> stmts;
    while (!check(TOK_RBRACE) && !at_end()) {
        stmts.push_back(parse_statement());
    }
    consume(TOK_RBRACE, "Expected '}' in parse_block");
    return std::make_shared<BlockStmt>(std::move(stmts));
}

std::vector<Token> Parser::collect_until_keyword_or(TokenType stop, const std::string& keyword) {
    std::vector<Token> out;
    int brace_depth = 0;
    int paren_depth = 0;
    while (!at_end()) {
        if (peek().type == TOK_LBRACE) brace_depth++;
        else if (peek().type == TOK_RBRACE) brace_depth--;
        else if (peek().type == TOK_LPAREN) paren_depth++;
        else if (peek().type == TOK_RPAREN) paren_depth--;
        if (brace_depth == 0 && paren_depth == 0 && peek().type == stop && peek().lexeme == keyword) {
            break;
        }
        out.push_back(advance());
    }
    return out;
}

std::shared_ptr<ASTNode> Parser::parse_head(const std::vector<Token>& head_tokens) {
    Parser sub(head_tokens);
    return sub.parse_expression();
}

std::shared_ptr<ASTNode> Parser::parse_statement() {
    if (match({TOK_LBRACE})) {
        return parse_block_no_open(); // parse block statement
    }

    if (check(TOK_KEYWORD)) {
        auto kw = peek().keyword.value();
        if (kw == Keyword::KW_LET) return parse_let();
        if (kw == Keyword::KW_GUARD) return parse_guard();
        if (kw == Keyword::KW_RETURN) return parse_return();
        if (kw == Keyword::KW_META) return parse_meta();
        if (kw == Keyword::KW_FUNC) return parse_function();
        if (kw == Keyword::KW_NAMESPACE) return parse_namespace();
    }

    // assignment
    if (check(TOK_IDENTIFIER) && tokens[current + 1].type == TOK_ASSIGN) {
        Token name = advance();
        advance();
        auto value = parse_expression();
        consume(TOK_SEMICOLON, "Expected ';' in assignment");
        return std::make_shared<Assignment>(name.lexeme, value);
    }

    // call
    if (check(TOK_IDENTIFIER) && tokens[current + 1].type == TOK_LPAREN) {
        Token callee_name = advance(); // consume identifier
        auto iden = std::make_shared<Variable>(callee_name.lexeme);
        auto call = parse_call(iden);
        auto call_expr = std::dynamic_pointer_cast<CallExpr>(call);
        consume(TOK_SEMICOLON, "Expected ';' in call");
        return call_expr;
    }

    auto expr = parse_expression();
    consume(TOK_SEMICOLON, "Expected ';' in expression");
    return std::make_shared<ExpressionStmt>(expr);
}

std::shared_ptr<ASTNode> Parser::parse_let() {
    consume(TOK_KEYWORD, "Expected 'let'");

    std::shared_ptr<ASTNode> pattern;

    // Handle destructuring patterns: {x, y} or [x, y]
    if (match({TOK_LBRACE})) {
        std::vector<std::string> names;
        do {
            Token name = consume(TOK_IDENTIFIER, "Expected identifier in destructuring");
            names.push_back(name.lexeme);
        } while (match({TOK_COMMA}));
        consume(TOK_RBRACE, "Expected '}' after destructuring pattern");

        pattern = std::make_shared<DestructurePattern>(names, /* isArray = */ false);
    } else if (match({TOK_LBRACKET})) {
        std::vector<std::string> names;
        do {
            Token name = consume(TOK_IDENTIFIER, "Expected identifier in destructuring");
            names.push_back(name.lexeme);
        } while (match({TOK_COMMA}));
        consume(TOK_RBRACKET, "Expected ']' after destructuring pattern");

        pattern = std::make_shared<DestructurePattern>(names, /* isArray = */ true);
    } else if (match({TOK_LPAREN})) {
        // Optional: support tuple grouping
        std::vector<std::string> names;
        do {
            Token name = consume(TOK_IDENTIFIER, "Expected identifier in tuple pattern");
            names.push_back(name.lexeme);
        } while (match({TOK_COMMA}));
        consume(TOK_RPAREN, "Expected ')' after tuple pattern");

        pattern = std::make_shared<TuplePattern>(names);
    } else {
        // Normal single-variable declaration
        Token name = consume(TOK_IDENTIFIER, "Expected identifier after 'let'");
        pattern = std::make_shared<VariablePattern>(name.lexeme);
    }

    // Optional type annotation
    std::optional<std::string> type_annotation;
    if (match({TOK_COLON})) {
        Token typeName = consume(TOK_IDENTIFIER, "Expected type name after ':'");
        type_annotation = typeName.lexeme;
    }

    // Optional initializer
    std::optional<std::shared_ptr<ASTNode>> initializer;
    if (match({TOK_ASSIGN})) {
        initializer = parse_expression();
    }

    consume(TOK_SEMICOLON, "Expected ';' after variable declaration");

    return std::make_shared<Declaration>(pattern, type_annotation, initializer);
}

std::shared_ptr<ASTNode> Parser::parse_function() {
    consume(TOK_KEYWORD, "Expected 'func' keyword.");

    auto name = std::make_shared<Variable>(consume(TOK_IDENTIFIER, "Expected function name.").lexeme);

    consume(TOK_LPAREN, "Expected '(' after function name.");

    std::vector<std::pair<std::shared_ptr<ASTNode>, std::shared_ptr<ASTNode>>> params;

    if (!check(TOK_RPAREN)) {
        do {
            auto paramName = std::make_shared<Variable>(consume(TOK_IDENTIFIER, "Expected parameter name.").lexeme);
            consume(TOK_COLON, "Expected ':' after parameter name.");
            auto paramType = std::make_shared<Variable>(consume(TOK_IDENTIFIER, "Expected parameter type.").lexeme);

            params.emplace_back(paramName, paramType);
        } while (match({TOK_COMMA}));
    }

    consume(TOK_RPAREN, "Expected ')' after parameters.");

    std::optional<std::shared_ptr<ASTNode>> returnType = std::nullopt;
    if (match({TOK_COLON})) {
        auto returnTypeNode = std::make_shared<Variable>(consume(TOK_IDENTIFIER, "Expected return type.").lexeme);
        returnType = returnTypeNode;
    }

    if (!check(TOK_LBRACE)) throw std::runtime_error("Expected '{' before function body.");

    auto block = parse_block();

    return std::make_shared<FunctionStmt>(
        std::move(name),
        std::move(params),
        std::move(returnType),
        std::move(block->statements)
    );

}

std::shared_ptr<ASTNode> Parser::parse_namespace() {
    consume(TOK_KEYWORD, "Expected 'namespace' keyword.");

    auto name = std::make_shared<Variable>(consume(TOK_IDENTIFIER, "Expected namespace name.").lexeme);

    if (!check(TOK_LBRACE)) throw std::runtime_error("Expected '{' after namespace name.");

    auto block = parse_block();

    return std::make_shared<Namespace>(
        std::move(name),
        std::move(block->statements)
    );

}

std::shared_ptr<ASTNode> Parser::parse_guard() {
    consume(TOK_KEYWORD, "Expected 'guard'");
    auto condition = parse_expression();
    Token e = consume(TOK_KEYWORD, "Expected 'else'");
    if (e.lexeme != "else") throw std::runtime_error("Expected 'else'");

    std::shared_ptr<ASTNode> else_branch;

    if (check(TOK_LBRACE)) {
        else_branch = parse_block();
        match({TOK_SEMICOLON});
    } else {
        auto ex = parse_expression();
        else_branch = std::make_shared<ReturnStmt>(ex);
        consume(TOK_SEMICOLON, "Expected ';' in guard");
    }

    return std::make_shared<GuardStmt>(condition, else_branch);
}

std::shared_ptr<BlockStmt> Parser::parse_block_no_open() {
    // DO NOT consume '{' â€” it was already matched before calling this function
    std::vector<std::shared_ptr<ASTNode>> stmts;
    while (!check(TOK_RBRACE) && !at_end()) {
        stmts.push_back(parse_statement());
    }
    consume(TOK_RBRACE, "Expected '}'");
    return std::make_shared<BlockStmt>(std::move(stmts));
}

// Assumes '{' has already been consumed
std::shared_ptr<BlockStmt> Parser::parse_block_already_open() {
    std::vector<std::shared_ptr<ASTNode>> stmts;
    while (!check(TOK_RBRACE) && !at_end()) {
        stmts.push_back(parse_statement());
    }
    consume(TOK_RBRACE, "Expected '}'");
    return std::make_shared<BlockStmt>(std::move(stmts));
}

std::shared_ptr<ASTNode> Parser::parse_return() {
    consume(TOK_KEYWORD, "Expected 'return'");
    std::optional<std::shared_ptr<ASTNode>> value;
    if (!check(TOK_SEMICOLON)) {
        value = parse_expression();
    }
    consume(TOK_SEMICOLON, "Expected ';' after return");
    return std::make_shared<ReturnStmt>(value);
}

std::shared_ptr<ASTNode> Parser::parse_meta() {
    auto ns = std::make_shared<Variable>(consume(TOK_KEYWORD, "Expected 'Meta'.").lexeme);
    consume(TOK_DOT, "Expected '.' after 'Meta' keyword.");

    auto accessor = std::make_shared<Variable>(consume(TOK_IDENTIFIER, "Expected identifier.").lexeme);

    auto a_ns = std::static_pointer_cast<ASTNode>(ns);
    auto a_accessor = std::static_pointer_cast<ASTNode>(accessor);

    if (check(TOK_LPAREN)) {
        auto call = parse_call(accessor); // returns shared_ptr<ASTNode>
        consume(TOK_SEMICOLON, "Expected ';' in meta");

        // Downcast to CallExpr
        auto call_expr = std::dynamic_pointer_cast<CallExpr>(call);
        if (!call_expr) {
            throw std::runtime_error("Expected function call after Meta accessor.");
        }

        return std::make_shared<MetaStmt>(
            a_ns,
            a_accessor,
            call_expr->arguments
        );
    } else if (check(TOK_SEMICOLON)) {
        consume(TOK_SEMICOLON, "Expected ';' in meta(2)");

        return std::make_shared<MetaStmt>(
            a_ns,
            a_accessor
        );
    } else {
        throw std::runtime_error("Unexpected token after 'Meta' accessor: '" + peek().lexeme + "'");
    }
}

std::shared_ptr<ASTNode> Parser::parse_expression() {
    return parse_assignment();
}


std::shared_ptr<ASTNode> Parser::parse_assignment() {
    auto node = parse_or();

    if (match({TOK_ASSIGN})) {
        Token equals = previous();
        auto value = parse_assignment(); // right-associative!

        if (auto var = std::dynamic_pointer_cast<Variable>(node)) {
            return std::make_shared<Assignment>(var->name, value);
        } else {
            throw std::runtime_error("Invalid assignment target");
        }
    }

    return node;
}

std::shared_ptr<ASTNode> Parser::parse_or() {
    auto node = parse_and();
    while (match({TOK_OR})) {
        Token op = previous();
        auto right = parse_and();
        node = std::make_shared<BinaryOp>(op.lexeme, node, right);
    }
    return node;
}

std::shared_ptr<ASTNode> Parser::parse_and() {
    auto node = parse_equality();
    while (match({TOK_AND})) {
        Token op = previous();
        auto right = parse_equality();
        node = std::make_shared<BinaryOp>(op.lexeme, node, right);
    }
    return node;
}

std::shared_ptr<ASTNode> Parser::parse_equality() {
    auto node = parse_comparison();
    while (match({TOK_EQUAL, TOK_NOT_EQUAL})) {
        Token op = previous();
        auto right = parse_comparison();
        node = std::make_shared<BinaryOp>(op.lexeme, node, right);
    }
    return node;
}

std::shared_ptr<ASTNode> Parser::parse_comparison() {
    auto node = parse_term();
    while (match({TOK_LESS, TOK_LESS_EQUAL, TOK_GREATER, TOK_GREATER_EQUAL})) {
        Token op = previous();
        auto right = parse_term();
        node = std::make_shared<BinaryOp>(op.lexeme, node, right);
    }
    return node;
}

std::shared_ptr<ASTNode> Parser::parse_term() {
    auto node = parse_factor();
    while (match({TOK_PLUS, TOK_MINUS})) {
        Token op = previous();
        auto right = parse_factor();
        node = std::make_shared<BinaryOp>(op.lexeme, node, right);
    }
    return node;
}

std::shared_ptr<ASTNode> Parser::parse_factor() {
    auto node = parse_unary();
    while (match({TOK_ASTERISK, TOK_SLASH, TOK_PERCENT})) {
        Token op = previous();
        auto right = parse_unary();
        node = std::make_shared<BinaryOp>(op.lexeme, node, right);
    }
    return node;
}

std::shared_ptr<ASTNode> Parser::parse_unary() {
    if (match({TOK_MINUS, TOK_NOT})) {
        Token op = previous();
        auto operand = parse_unary();
        return std::make_shared<UnaryOp>(op.lexeme, operand);
    }
    return parse_primary();
}

std::shared_ptr<ASTNode> Parser::parse_primary() {
    if (match({TOK_INTEGER, TOK_DECIMAL, TOK_STRING})) {
        return std::make_shared<Literal>(previous().lexeme);
    }
    if (match({TOK_KEYWORD})) {
        auto kw = previous().keyword.value();
        if (kw == Keyword::KW_TRUE || kw == Keyword::KW_FALSE || kw == Keyword::KW_NIL || kw == Keyword::KW_NIX || kw == Keyword::KW_NAN) {
            return std::make_shared<Literal>(previous().lexeme);
        }

        if (kw == Keyword::KW_META) {
            // Special handling for Meta
            auto meta_ns = std::make_shared<Variable>("Meta");
            consume(TOK_DOT, "Expected '.' after 'Meta'");
            auto accessor = std::make_shared<Variable>(consume(TOK_IDENTIFIER, "Expected Meta accessor").lexeme);

            // If it's a function call (Meta.Time()), parse call
            if (check(TOK_LPAREN)) {
                auto call = parse_call(accessor);
                auto call_expr = std::dynamic_pointer_cast<CallExpr>(call);
                if (!call_expr) throw std::runtime_error("Expected function call after Meta accessor.");

                return std::make_shared<MetaStmt>(
                    std::static_pointer_cast<ASTNode>(meta_ns),
                    std::static_pointer_cast<ASTNode>(accessor),
                    call_expr->arguments
                );
            }
            // If just property access (Meta.Something)
            else {
                return std::make_shared<MetaStmt>(
                    std::static_pointer_cast<ASTNode>(meta_ns),
                    std::static_pointer_cast<ASTNode>(accessor)
                );
            }
        }
        throw std::runtime_error("Unexpected keyword '" + previous().lexeme + "'");
    }
    if (match({TOK_IDENTIFIER})) {
        std::shared_ptr<ASTNode> expr = std::make_shared<Variable>(previous().lexeme);

        while (match({TOK_DOT})) {
            Token name = consume(TOK_IDENTIFIER, "Expected property name after '.'");
            expr = std::make_shared<FieldAccess>(expr, std::make_shared<Variable>(name.lexeme));
        }

        if (check(TOK_LPAREN)) {
            expr = parse_call(expr);
        }

        return expr;
    }
    if (match({TOK_LPAREN})) {
        auto expr = parse_expression();
        consume(TOK_RPAREN, "Expected ')'");
        return expr;
    }
    throw std::runtime_error("Unexpected token: " + peek().lexeme);
}


std::shared_ptr<ASTNode> Parser::parse_call(std::shared_ptr<ASTNode> callee) {
    consume(TOK_LPAREN, "Expected '(' after function name");

    std::vector<std::shared_ptr<ASTNode>> arguments;

    if (!check(TOK_RPAREN)) {
        do {
            arguments.push_back(parse_expression());
        } while (match({TOK_COMMA}));
    }

    consume(TOK_RPAREN, "Expected ')' after arguments");

    return std::make_shared<CallExpr>(callee, arguments);
}

# ```
# 

```./frontend/AST.hpp
#pragma once

#include <string>
#include <memory>
#include <vector>
#include <optional>

// --- AST Node Types ---
enum class ASTNodeType {
    LITERAL,
    VARIABLE,
    BINARY_OP,
    UNARY_OP,
    DECLARATION,
    VARIABLE_PATTERN,
    TUPLE_PATTERN,
    DESTRUCTURE_PATTERN,
    ASSIGNMENT,
    EXPRESSION_STMT,
    PRINT_STMT,
    IF_STMT,
    META_STMT,
    GUARD_STMT,
    WHILE_STMT,
    FOR_IN_STMT,
    BLOCK_STMT,
    FUNCTION_STMT,
    CALL_EXPR,
    RETURN_STMT,
    STRUCT_DECL,
    IMPORT_DECL,
    FIELD_ACCESS,
    NAMESPACE_DECL,
};

// --- Base AST Node ---
struct ASTNode {
    ASTNodeType type;
    virtual ~ASTNode();
};

// --- Literal Node ---
struct Literal : ASTNode {
    std::string value;
    explicit Literal(const std::string& val);
    bool is_str();
    bool is_int();
    bool is_dec();
};

// --- Variable Reference Node ---
struct Variable : ASTNode {
    std::string name;
    explicit Variable(const std::string& n);
};

// --- Namespace Reference Node ---
struct Namespace : ASTNode {
    std::shared_ptr<ASTNode> name;
    std::vector<std::shared_ptr<ASTNode>> body;
    explicit Namespace(const std::shared_ptr<ASTNode> n, std::vector<std::shared_ptr<ASTNode>> body);
};

// --- Binary Operation Node ---
struct BinaryOp : ASTNode {
    std::string op;
    std::shared_ptr<ASTNode> left, right;
    BinaryOp(const std::string& oper,
             std::shared_ptr<ASTNode> lhs,
             std::shared_ptr<ASTNode> rhs);
};

// --- Unary Operation Node ---
struct UnaryOp : ASTNode {
    std::string op;
    std::shared_ptr<ASTNode> operand;
    UnaryOp(const std::string& oper,
            std::shared_ptr<ASTNode> opd);
};

// --- Declaration (let or const) Node ---
struct Declaration : public ASTNode {
    std::shared_ptr<ASTNode> pattern;
    std::optional<std::string> type_annotation;
    std::optional<std::shared_ptr<ASTNode>> initializer;

    Declaration(std::shared_ptr<ASTNode> pattern,
                std::optional<std::string> type_annotation,
                std::optional<std::shared_ptr<ASTNode>> initializer);
};

// --- VariablePattern Node ---
struct VariablePattern : public ASTNode {
    std::string name;

    VariablePattern(const std::string& name);
};

// --- TuplePattern Node ---
struct TuplePattern : public ASTNode {
    std::vector<std::string> names;

    TuplePattern(std::vector<std::string> names);
};

// --- DestructurePattern Node ---
struct DestructurePattern : public ASTNode {
    std::vector<std::string> names;
    bool isArray; // true = array destructuring, false = object destructuring

    DestructurePattern(std::vector<std::string> names, bool isArray);
};

// --- Assignment Node ---
struct Assignment : ASTNode {
    std::string name;
    std::shared_ptr<ASTNode> value;
    Assignment(const std::string& n,
               std::shared_ptr<ASTNode> val);
};

// --- Expression Statement Node ---
struct ExpressionStmt : ASTNode {
    std::shared_ptr<ASTNode> expression;
    explicit ExpressionStmt(std::shared_ptr<ASTNode> expr);
};

// --- If Statement Node ---
struct IfStmt : ASTNode {
    std::shared_ptr<ASTNode> condition;
    std::shared_ptr<ASTNode> thenBranch;
    std::vector<std::shared_ptr<ASTNode>> elifBranches;
    std::optional<std::shared_ptr<ASTNode>> elseBranch;

    IfStmt(std::shared_ptr<ASTNode> cond,
           std::shared_ptr<ASTNode> thenB,
           std::vector<std::shared_ptr<ASTNode>> elifB = {},
           std::optional<std::shared_ptr<ASTNode>> elseB = std::nullopt);
};

// --- Meta NS Call ---
//  e.g. Meta::RAW_EMIT("(WRITE)");
struct MetaStmt : ASTNode {
    std::shared_ptr<ASTNode> ns; // namespace (i.e. 'Meta')
    std::shared_ptr<ASTNode> call; // e.g. 'RAW_EMIT'
    std::optional<std::vector<std::shared_ptr<ASTNode>>> arg; // if set, call function; else treat as var

    MetaStmt(
        std::shared_ptr<ASTNode> ns,
        std::shared_ptr<ASTNode> call,
        std::optional<std::vector<std::shared_ptr<ASTNode>>> arg
    );

    MetaStmt(
        std::shared_ptr<ASTNode> ns,
        std::shared_ptr<ASTNode> call
    );
};

struct ElifBranch : ASTNode {
    std::shared_ptr<ASTNode> condition;
    std::shared_ptr<ASTNode> thenBranch;
};

// --- Guard Statement Node ---
struct GuardStmt : ASTNode {
    std::shared_ptr<ASTNode> condition;
    std::shared_ptr<ASTNode> elseBranch;
    GuardStmt(std::shared_ptr<ASTNode> cond,
           std::shared_ptr<ASTNode> elseB);
};

// --- While Statement Node ---
struct WhileStmt : ASTNode {
    std::shared_ptr<ASTNode> condition;
    std::shared_ptr<ASTNode> body;
    WhileStmt(std::shared_ptr<ASTNode> cond,
              std::shared_ptr<ASTNode> b);
};

// --- For-In Statement Node ---
struct ForInStmt : ASTNode {
    std::string varName;
    std::shared_ptr<ASTNode> iterable;
    std::shared_ptr<ASTNode> body;
    ForInStmt(const std::string& n,
              std::shared_ptr<ASTNode> iter,
              std::shared_ptr<ASTNode> b);
};

// --- Block Statement Node ---
struct BlockStmt : ASTNode {
    std::vector<std::shared_ptr<ASTNode>> statements;
    explicit BlockStmt(std::vector<std::shared_ptr<ASTNode>> stmts);
};

// --- Function Declaration Node ---
struct FunctionStmt : ASTNode {
    std::shared_ptr<ASTNode> name;
    std::vector<std::pair<std::shared_ptr<ASTNode>, std::shared_ptr<ASTNode>>> params; // (paramName, paramType)
    std::optional<std::shared_ptr<ASTNode>> returnType;
    std::vector<std::shared_ptr<ASTNode>> body; // Function body block

    FunctionStmt(
        std::shared_ptr<ASTNode> name,
        std::vector<std::pair<std::shared_ptr<ASTNode>, std::shared_ptr<ASTNode>>> params,
        std::optional<std::shared_ptr<ASTNode>> returnType,
        std::vector<std::shared_ptr<ASTNode>> body
    );
};

// --- Access Node (e.g. "Math.sin") ---
struct FieldAccess : ASTNode {
    std::shared_ptr<ASTNode> object;
    std::shared_ptr<ASTNode> field;

    FieldAccess(std::shared_ptr<ASTNode> object, std::shared_ptr<ASTNode> field);
};

// --- Call Expression Node ---
struct CallExpr : ASTNode {
    std::shared_ptr<ASTNode> callee;
    std::vector<std::shared_ptr<ASTNode>> arguments;
    CallExpr(std::shared_ptr<ASTNode> c,
             std::vector<std::shared_ptr<ASTNode>> args);
};

// --- Return Statement Node ---
struct ReturnStmt : ASTNode {
    std::optional<std::shared_ptr<ASTNode>> value;
    explicit ReturnStmt(std::optional<std::shared_ptr<ASTNode>> v = std::nullopt);
};

// --- Struct Declaration Node ---
struct StructDecl : ASTNode {
    std::string name;
    std::vector<std::string> fields;
    StructDecl(const std::string& n,
               std::vector<std::string> f);
};

// --- Import Declaration Node ---
struct ImportDecl : ASTNode {
    std::string module;
    std::optional<std::string> alias;
    ImportDecl(const std::string& m,
               std::optional<std::string> a = std::nullopt);
};

std::string ast_to_string(const std::shared_ptr<ASTNode>& node);

# ```
# 

```./vm/obj/Integer.hpp
#pragma once
#include "Scalar.hpp"

class Integer : public Scalar {
public:
    int64_t value;
    Integer(int64_t v);

    std::string __str__() const override;
    bool __bool__() const override;
    std::string __name__() const override;

    std::shared_ptr<Object> __add__(const Object& o) const override;
    std::shared_ptr<Object> __sub__(const Object& o) const override;
    std::shared_ptr<Object> __mul__(const Object& o) const override;
    std::shared_ptr<Object> __div__(const Object& o) const override;
    std::shared_ptr<Object> __mod__(const Object& o) const override;

    std::shared_ptr<Object> __eq__ (const Object& o) const override;
    std::shared_ptr<Object> __lt__ (const Object& o) const override;
    std::shared_ptr<Object> __gt__ (const Object& o) const override;
    std::shared_ptr<Object> __le__ (const Object& o) const override;
    std::shared_ptr<Object> __ge__ (const Object& o) const override;
    std::shared_ptr<Object> __and__(const Object& o) const override;
    std::shared_ptr<Object> __or__ (const Object& o) const override;
    std::shared_ptr<Object> __not__() const override;
};

# ```
# 

```./vm/obj/Boolean.hpp
#pragma once
#include "Object.hpp"

class Boolean : public Object {
public:
    bool value;
    Boolean(bool v);

    std::string __str__() const override;
    bool __bool__() const override;
    std::string __name__() const override;

    std::shared_ptr<Object> __eq__ (const Object& o) const override;
    std::shared_ptr<Object> __and__ (const Object& o) const override;
    std::shared_ptr<Object> __or__ (const Object& o) const override;
    std::shared_ptr<Object> __not__ () const override;
};

# ```
# 

```./vm/obj/NaN.cpp
#include "NaN.hpp"
#include <limits>

std::string NaN::__str__() const {
    return "NaN";
}

bool NaN::__bool__() const {
    return false;
}

double NaN::__double__() const {
    return std::numeric_limits<double>::quiet_NaN();
}

int64_t NaN::__int__() const {
    return 0;
}

std::string NaN::__name__() const {
    return "NaN";
}

std::shared_ptr<NaN> NaN::instance() {
    static std::shared_ptr<NaN> inst = std::make_shared<NaN>();
    return inst;
}

# ```
# 

```./vm/obj/RegEx.hpp
#pragma once
#include "String.hpp"
#include <set>

class RegEx : public String {
public:
    std::set<char> flags;

    RegEx(const std::string& pattern, const std::set<char>& flags = {});

    std::string __name__() const override;

    bool has_flag(char flag) const;
};

# ```
# 

```./vm/obj/BuiltinFn.hpp
#pragma once

#include <functional>
#include <string>
#include "../core/Process.hpp"
#include "Object.hpp"

class BuiltinFn : public Object {
public:
    // The wrapped C++ function takes the VM process and returns
    // true on success (false â†’ error)
    using FnType = std::function<bool(Process&)>;

    BuiltinFn(FnType fn, std::string name);

    // Object interface
    std::string __str__()   const override;
    bool        __bool__()  const override;
    std::string __name__()  const override;

    // Invoke this function in the VM
    bool invoke(Process& p) const;

private:
    FnType      fn_;
    std::string name_;
};

# ```
# 

```./vm/obj/FunctionObject.cpp
// vm/obj/FunctionObject.cpp
#include "FunctionObject.hpp"
#include <stdexcept>

FunctionObject::FunctionObject(std::string label, size_t arity)
  : label_(std::move(label)), arity_(arity), receiver_(nullptr)
{}

FunctionObject::FunctionObject(std::string label, size_t arity, std::shared_ptr<Object> receiver)
  : label_(std::move(label)), arity_(arity), receiver_(std::move(receiver))
{}

std::string FunctionObject::__str__() const {
    return "<function " + label_ + ">";
}

bool FunctionObject::__bool__() const {
    return true;
}

std::string FunctionObject::__name__() const {
    return label_;
}

bool FunctionObject::invoke(Process& p) const {
    // 1) make sure there are enough args on the stack
    if (p.stack.size() < arity_) {
        throw std::runtime_error("Call to " + label_ + " expects "
                                 + std::to_string(arity_) + " arguments");
    }

    // 2) push a new local-scope frame
    p.env_stack.push_scope();

    // 3) if this was a bound method, bind it as `this`
    if (receiver_) {
        p.env_stack.declare("this");
        p.env_stack.set("this", receiver_);
    }

    // (The functionâ€™s own Bytecode will DECL its parameters in order,
    // so we donâ€™t need to name them here.)

    // 4) save return address
    p.callstack.push(p.pc + 1);

    // 5) jump to the functionâ€™s label
    if (!p.labels.exists(label_)) {
        throw std::runtime_error("Unknown function label: " + label_);
    }
    p.pc = p.labels.get(label_);
    return true;
}

# ```
# 

```./vm/obj/Nil.hpp
#pragma once
#include "Object.hpp"

class Nil : public Object {
public:
    std::string __str__() const override;
    bool __bool__() const override;
    std::string __name__() const override;

    // Singleton pattern
    static std::shared_ptr<Nil> instance();
};

# ```
# 

```./vm/obj/Scalar.cpp
#include "Scalar.hpp"

# ```
# 

```./vm/obj/Object.cpp
#include "Object.hpp"
#include <stdexcept>

// Arithmetic & comparison
std::shared_ptr<Object> Object::__add__ (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for +"); }
std::shared_ptr<Object> Object::__sub__ (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for -"); }
std::shared_ptr<Object> Object::__mul__ (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for *"); }
std::shared_ptr<Object> Object::__div__ (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for /"); }
std::shared_ptr<Object> Object::__pow__ (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for **"); }
std::shared_ptr<Object> Object::__mod__ (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for %"); }

std::shared_ptr<Object> Object::__eq__  (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for =="); }
std::shared_ptr<Object> Object::__lt__  (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for <"); }
std::shared_ptr<Object> Object::__gt__  (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for >"); }
std::shared_ptr<Object> Object::__le__  (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for <="); }
std::shared_ptr<Object> Object::__ge__  (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for >="); }

std::shared_ptr<Object> Object::__and__ (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for &&"); }
std::shared_ptr<Object> Object::__or__  (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for ||"); }
std::shared_ptr<Object> Object::__not__ () const                { throw std::runtime_error("Unsupported operand type(s) for !"); }

// Numeric unary
std::shared_ptr<Object> Object::__abs__() const     { throw std::runtime_error("Unsupported operand type(s) for abs()"); }
std::shared_ptr<Object> Object::__sqrt__() const    { throw std::runtime_error("Unsupported operand type(s) for sqrt()"); }

// Logarithmic
std::shared_ptr<Object> Object::__ln__   (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for ln()"); }
std::shared_ptr<Object> Object::__log10__() const                { throw std::runtime_error("Unsupported operand type(s) for log10()"); }
std::shared_ptr<Object> Object::__log2__ () const                { throw std::runtime_error("Unsupported operand type(s) for log2()"); }
std::shared_ptr<Object> Object::__exp__  () const                { throw std::runtime_error("Unsupported operand type(s) for exp()"); }

// Trigonometric
std::shared_ptr<Object> Object::__sin__()     const { throw std::runtime_error("Unsupported operand type(s) for sin()"); }
std::shared_ptr<Object> Object::__cos__()     const { throw std::runtime_error("Unsupported operand type(s) for cos()"); }
std::shared_ptr<Object> Object::__tan__()     const { throw std::runtime_error("Unsupported operand type(s) for tan()"); }
std::shared_ptr<Object> Object::__csc__()     const { throw std::runtime_error("Unsupported operand type(s) for csc()"); }
std::shared_ptr<Object> Object::__sec__()     const { throw std::runtime_error("Unsupported operand type(s) for sec()"); }
std::shared_ptr<Object> Object::__cot__()     const { throw std::runtime_error("Unsupported operand type(s) for cot()"); }

// Inverse trig
std::shared_ptr<Object> Object::__arcsin__()  const { throw std::runtime_error("Unsupported operand type(s) for arcsin()"); }
std::shared_ptr<Object> Object::__arccos__()  const { throw std::runtime_error("Unsupported operand type(s) for arccos()"); }
std::shared_ptr<Object> Object::__arctan__()  const { throw std::runtime_error("Unsupported operand type(s) for arctan()"); }
std::shared_ptr<Object> Object::__arccsc__()  const { throw std::runtime_error("Unsupported operand type(s) for arccsc()"); }
std::shared_ptr<Object> Object::__arcsec__()  const { throw std::runtime_error("Unsupported operand type(s) for arcsec()"); }
std::shared_ptr<Object> Object::__arccot__()  const { throw std::runtime_error("Unsupported operand type(s) for arccot()"); }

// Iteration
std::shared_ptr<Object> Object::__iter__() const { throw std::runtime_error("Object is not iterable"); }
std::shared_ptr<Object> Object::__next__()       { throw std::runtime_error("Iteration not supported"); }


std::shared_ptr<Object> Object::getField(const std::string& name)  {
  return nullptr;
}
void Object::setField(const std::string& name,
                      std::shared_ptr<Object> value) {
  throw std::runtime_error(
    __name__() + " is not an instance and cannot have fields"
  );
}

bool Object::hasMethod(const std::string& /*name*/) {
    return false;
}

std::shared_ptr<Object> Object::getMethod(const std::string& /*name*/) {
    return nullptr;
}

# ```
# 

```./vm/obj/Nix.hpp
#pragma once
#include "Object.hpp"

class Nix : public Object {
public:
    std::string __str__() const override;
    bool __bool__() const override;
    std::string __name__() const override;

    // Prevent any operation on undefined
    std::shared_ptr<Object> __add__(const Object&) const override;
    std::shared_ptr<Object> __not__() const override;

    static std::shared_ptr<Nix> instance();
};

# ```
# 

```./vm/obj/Float.hpp
#pragma once
#include "Scalar.hpp"

class Float : public Scalar {
public:
    double value;
    Float(double v);

    std::string __str__() const override;
    bool __bool__() const override;
    std::string __name__() const override;

    std::shared_ptr<Object> __add__(const Object& o) const override;
    std::shared_ptr<Object> __sub__(const Object& o) const override;
    std::shared_ptr<Object> __mul__(const Object& o) const override;
    std::shared_ptr<Object> __div__(const Object& o) const override;

    std::shared_ptr<Object> __eq__ (const Object& o) const override;
    std::shared_ptr<Object> __lt__ (const Object& o) const override;
    std::shared_ptr<Object> __gt__ (const Object& o) const override;
    std::shared_ptr<Object> __le__ (const Object& o) const override;
    std::shared_ptr<Object> __ge__ (const Object& o) const override;
    std::shared_ptr<Object> __and__(const Object& o) const override;
    std::shared_ptr<Object> __or__ (const Object& o) const override;
    std::shared_ptr<Object> __not__() const override;
};

# ```
# 

```./vm/obj/ClassObject.cpp
#include "ClassObject.hpp"
#include <stdexcept>

ClassObject::ClassObject(std::string name, size_t arity, FactoryFn factory)
  : name_(std::move(name))
  , arity_(arity)
  , factory_(std::move(factory))
{}

bool ClassObject::invoke(Process& p) const {
    if (p.stack.size() < arity_) {
        throw std::runtime_error(
          "Constructor " + name_ + " expects "
          + std::to_string(arity_) + " arguments");
    }

    // 1) pop the args in reverse order
    std::vector<std::shared_ptr<Object>> args(arity_);
    for (size_t i = 0; i < arity_; ++i) {
        args[arity_ - 1 - i] = p.stack.pop();
    }

    // 2) call your factory to build & initialize
    auto instance = factory_(args);
    if (!instance) {
        throw std::runtime_error("Factory for " + name_ + " returned null");
    }

    // 3) push the new instance
    p.stack.push(instance);
    return true;
}

# ```
# 

```./vm/obj/List.hpp
#pragma once
#include "Object.hpp"
#include <vector>
#include <memory>
#include <string>

class List : public Object {
public:
    std::vector<std::shared_ptr<Object>> items;

    List();

    std::string __str__() const override;
    std::string __name__() const override;
    bool __bool__() const override;
    int64_t __int__() const override;
    double __double__() const override;

    std::shared_ptr<Object> get_at(const std::shared_ptr<Object>& index) const;
    void set_at(const std::shared_ptr<Object>& index, const std::shared_ptr<Object>& value);
    void insert(const std::shared_ptr<Object>& index, const std::shared_ptr<Object>& value);
    void remove(const std::shared_ptr<Object>& value);
    size_t size() const;
};

# ```
# 

```./vm/obj/String.cpp
#include "String.hpp"
#include "Boolean.hpp"
#include "Integer.hpp"
#include <memory>

String::String(const std::string& v) : value(v) {}

std::string String::__str__() const {
    return value;
}

bool String::__bool__() const {
    return !value.empty();
}

std::string String::__name__() const {
    return "string";
}

std::shared_ptr<Object> String::__add__(const Object& o) const {
    return std::make_shared<String>(value + o.__str__());
}

std::shared_ptr<Object> String::__eq__(const Object& o) const {
    const auto* p = dynamic_cast<const String*>(&o);
    if (!p) return std::make_shared<Boolean>(false);
    return std::make_shared<Boolean>(value == p->value);
}
std::shared_ptr<Object> String::__mul__(const Object& o) const {
    const auto* p = dynamic_cast<const Integer*>(&o);
    if (!p) throw std::runtime_error("TypeError: string * " + o.__name__());
    std::string out;
    for (int i = 0; i < p->value; ++i) out += value;
    return std::make_shared<String>(out);
}

# ```
# 

```./vm/obj/Nil.cpp
#include "Nil.hpp"
#include "Nil.hpp"

std::string Nil::__str__() const {
    return "null";
}

bool Nil::__bool__() const {
    return false;
}

std::string Nil::__name__() const {
    return "Nil";
}

std::shared_ptr<Nil> Nil::instance() {
    static std::shared_ptr<Nil> inst = std::make_shared<Nil>();
    return inst;
}

# ```
# 

```./vm/obj/Object.hpp
#pragma once
#include <string>

class Object : public std::enable_shared_from_this<Object> {
public:
    virtual std::string __str__()   const = 0;
    virtual bool        __bool__()  const { return true; }
    virtual int64_t     __int__()  const { return 0; }
    virtual double      __double__()  const { return 0; }

    // arithmetic & comparison
    virtual std::shared_ptr<Object> __add__ (const Object& o) const;
    virtual std::shared_ptr<Object> __sub__ (const Object& o) const;
    virtual std::shared_ptr<Object> __mul__ (const Object& o) const;
    virtual std::shared_ptr<Object> __div__ (const Object& o) const;
    virtual std::shared_ptr<Object> __pow__ (const Object& o) const;
    virtual std::shared_ptr<Object> __abs__ () const;
    virtual std::shared_ptr<Object> __sqrt__ () const;
    virtual std::shared_ptr<Object> __mod__ (const Object& o) const;
    virtual std::shared_ptr<Object> __eq__  (const Object& o) const;
    virtual std::shared_ptr<Object> __lt__  (const Object& o) const;
    virtual std::shared_ptr<Object> __gt__  (const Object& o) const;
    virtual std::shared_ptr<Object> __le__  (const Object& o) const;
    virtual std::shared_ptr<Object> __ge__  (const Object& o) const;
    virtual std::shared_ptr<Object> __ln__  (const Object& o) const;
    virtual std::shared_ptr<Object> __log10__  () const;
    virtual std::shared_ptr<Object> __log2__  () const;
    virtual std::shared_ptr<Object> __sin__() const;
    virtual std::shared_ptr<Object> __cos__() const;
    virtual std::shared_ptr<Object> __tan__() const;
    virtual std::shared_ptr<Object> __csc__() const;
    virtual std::shared_ptr<Object> __sec__() const;
    virtual std::shared_ptr<Object> __cot__() const;
    virtual std::shared_ptr<Object> __arcsin__() const;
    virtual std::shared_ptr<Object> __arccos__() const;
    virtual std::shared_ptr<Object> __arctan__() const;
    virtual std::shared_ptr<Object> __arccsc__() const;
    virtual std::shared_ptr<Object> __arcsec__() const;
    virtual std::shared_ptr<Object> __arccot__() const;
    virtual std::shared_ptr<Object> __exp__() const;

    virtual std::shared_ptr<Object> __and__(const Object& o) const;
    virtual std::shared_ptr<Object> __or__ (const Object& o) const;
    virtual std::shared_ptr<Object> __not__() const;

    // iteration protocol
    virtual std::shared_ptr<Object> __iter__() const;
    virtual std::shared_ptr<Object> __next__();

    // method protocol
    virtual std::shared_ptr<Object> getField(const std::string& name);
    virtual void setField(const std::string& name,
                            std::shared_ptr<Object> value);
    virtual bool hasMethod(const std::string& name);
    virtual std::shared_ptr<Object> getMethod(const std::string& name);

    virtual std::string __name__() const = 0;
    virtual ~Object() = default;
};

# ```
# 

```./vm/obj/Scalar.hpp
#pragma once
#include "Object.hpp"

class Scalar : public Object {
public:
    virtual ~Scalar() = default;
};

# ```
# 

```./vm/obj/Float.cpp
#include "Float.hpp"
#include "Integer.hpp"
#include "Boolean.hpp"
#include "String.hpp"
#include <memory>

Float::Float(double v) : value(v) {}

std::string Float::__str__() const {
    return std::to_string(value);
}

bool Float::__bool__() const {
    return value != 0.0;
}

std::string Float::__name__() const {
    return "decimal";
}

std::shared_ptr<Object> Float::__add__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        return std::make_shared<Float>(value + p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Float>(value + static_cast<double>(p->value));
    }
    if (const auto* p = dynamic_cast<const String*>(&o)) {
        return std::make_shared<String>(__str__() + p->value);
    }
    throw std::runtime_error("TypeError: decimal + " + o.__name__());
}

std::shared_ptr<Object> Float::__sub__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        return std::make_shared<Float>(value - p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Float>(value - static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: decimal - " + o.__name__());
}

std::shared_ptr<Object> Float::__mul__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        return std::make_shared<Float>(value * p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Float>(value * static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: decimal * " + o.__name__());
}

std::shared_ptr<Object> Float::__div__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        if (p->value == 0.0) throw std::runtime_error("ZeroDivisionError: decimal / decimal");
        return std::make_shared<Float>(value / p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        if (p->value == 0) throw std::runtime_error("ZeroDivisionError: decimal / integer");
        return std::make_shared<Float>(value / static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: decimal / " + o.__name__());
}

std::shared_ptr<Object> Float::__eq__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        return std::make_shared<Boolean>(value == p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value == static_cast<double>(p->value));
    }
    return std::make_shared<Boolean>(false);
}

std::shared_ptr<Object> Float::__lt__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        return std::make_shared<Boolean>(value < p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value < static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: decimal < " + o.__name__());
}

std::shared_ptr<Object> Float::__gt__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        return std::make_shared<Boolean>(value > p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value > static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: decimal > " + o.__name__());
}

std::shared_ptr<Object> Float::__le__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        return std::make_shared<Boolean>(value <= p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value <= static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: decimal <= " + o.__name__());
}

std::shared_ptr<Object> Float::__ge__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        return std::make_shared<Boolean>(value >= p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value >= static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: decimal >= " + o.__name__());
}


std::shared_ptr<Object> Float::__or__(const Object& o) const {
    return std::make_shared<Boolean>(__bool__() || o.__bool__());
}
std::shared_ptr<Object> Float::__and__(const Object& o) const {
    return std::make_shared<Boolean>(__bool__() && o.__bool__());
}
std::shared_ptr<Object> Float::__not__() const {
    return std::make_shared<Boolean>(!__bool__());
}

# ```
# 

```./vm/obj/Nix.cpp
#include "Nix.hpp"
#include <stdexcept>

std::string Nix::__str__() const {
    return "undefined";
}

bool Nix::__bool__() const {
    return false;
}

std::string Nix::__name__() const {
    return "Nix";
}

std::shared_ptr<Nix> Nix::instance() {
    static std::shared_ptr<Nix> inst = std::make_shared<Nix>();
    return inst;
}

std::shared_ptr<Object> Nix::__add__(const Object&) const {
    throw std::runtime_error("Cannot perform operations on 'undefined'");
}

std::shared_ptr<Object> Nix::__not__() const {
    throw std::runtime_error("Cannot perform operations on 'undefined'");
}

# ```
# 

```./vm/obj/ClassObject.hpp
#pragma once

#include <string>
#include <vector>
#include <functional>
#include <memory>
#include "../core/Process.hpp"
#include "Object.hpp"

/// A ClassObject is itself callable:
///   ClassObject(name, arity, factory)
/// when invoked it:
///  1) pops exactly arity args
///  2) calls factory(args) â†’ an initialized instance
///  3) pushes that instance
class ClassObject : public Object {
public:
    using FactoryFn = std::function<std::shared_ptr<Object>(
        const std::vector<std::shared_ptr<Object>>& args)>;

    ClassObject(std::string name, size_t arity, FactoryFn factory);

    // Object protocol
    std::string __str__()  const override { return "<class " + name_ + ">"; }
    bool        __bool__() const override { return true;                    }
    std::string __name__() const override { return name_;                    }

    /// Invoke as a constructor
    /// pops arity args, calls factory, pushes instance
    bool invoke(Process& p) const;
    std::shared_ptr<Object> getField(const std::string& name) const {
      auto it = statics_.find(name);
      if (it != statics_.end()) return it->second;
      return nullptr;
    }

    void setField(const std::string& name,
                  std::shared_ptr<Object> val) override {
      statics_[name] = std::move(val);
    }

private:
    std::string name_;
    size_t      arity_;
    FactoryFn  factory_;
    std::unordered_map<std::string, std::shared_ptr<Object>> statics_;
};

# ```
# 

```./vm/obj/List.cpp
#include "List.hpp"
#include "Integer.hpp"
#include <sstream>
#include <stdexcept>

List::List() {}

std::string List::__str__() const {
    std::ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < items.size(); ++i) {
        oss << items[i]->__str__();
        if (i + 1 < items.size()) oss << ", ";
    }
    oss << "]";
    return oss.str();
}

std::string List::__name__() const {
    return "List";
}

bool List::__bool__() const {
    return !items.empty();
}

int64_t List::__int__() const {
    return static_cast<int64_t>(items.size());
}

double List::__double__() const {
    return static_cast<double>(items.size());
}

std::shared_ptr<Object> List::get_at(const std::shared_ptr<Object>& index) const {
    auto i = std::dynamic_pointer_cast<Integer>(index);
    if (!i) throw std::runtime_error("List index must be an Integer");
    if (i->value < 0 || static_cast<size_t>(i->value) >= items.size())
        throw std::out_of_range("List index out of range: " + std::to_string(i->value));
    return items[i->value];
}

void List::set_at(const std::shared_ptr<Object>& index, const std::shared_ptr<Object>& value) {
    auto i = std::dynamic_pointer_cast<Integer>(index);
    if (!i) throw std::runtime_error("List index must be an Integer");
    if (i->value < 0 || static_cast<size_t>(i->value) >= items.size())
        throw std::out_of_range("List index out of range: " + std::to_string(i->value));
    items[i->value] = value;
}

void List::insert(const std::shared_ptr<Object>& index, const std::shared_ptr<Object>& value) {
    auto i = std::dynamic_pointer_cast<Integer>(index);
    if (!i) throw std::runtime_error("List index must be an Integer");
    if (i->value < 0 || static_cast<size_t>(i->value) > items.size())
        throw std::out_of_range("List index out of range: " + std::to_string(i->value));
    items.insert(items.begin() + i->value, value);
}

void List::remove(const std::shared_ptr<Object>& value) {
    for (auto it = items.begin(); it != items.end(); ++it) {
        if ((*it)->__eq__(*value)->__bool__()) {
            items.erase(it);
            return;
        }
    }
    throw std::runtime_error("Value not found in list");
}

size_t List::size() const {
    return items.size();
}

# ```
# 

```./vm/obj/String.hpp
#pragma once
#include "Object.hpp"
#include <string>

class String : public Object {
public:
    std::string value;

    String(const std::string& v);

    std::string __str__() const override;
    bool __bool__() const override;
    std::string __name__() const override;

    std::shared_ptr<Object> __add__(const Object& o) const override;
    std::shared_ptr<Object> __mul__(const Object& o) const override;
    std::shared_ptr<Object> __eq__(const Object& o) const override;
};

# ```
# 

```./vm/obj/InstanceObject.hpp
#pragma once

#include "Object.hpp"
#include "ClassObject.hpp"
#include <unordered_map>
#include <memory>
#include <string>

class InstanceObject : public Object {
public:
  explicit InstanceObject(std::shared_ptr<ClassObject> cls)
    : cls_(std::move(cls)) {}

  // --- fields ---
  std::shared_ptr<Object> getField(const std::string& name) const {
    // 1) instanceâ€level field?
    auto it = fields_.find(name);
    if (it != fields_.end()) return it->second;
    // 2) else fall back to "static" classâ€property
    return cls_->getField(name);
  }

  void setField(const std::string& name,
                std::shared_ptr<Object> value) override {
    fields_[name] = std::move(value);
  }

  // --- methods defer to class ---
  bool hasMethod(const std::string& name) const {
    return cls_->hasMethod(name);
  }
  std::shared_ptr<Object> getMethod(const std::string& name) const {
    return cls_->getMethod(name);
  }

  // pick a string rep
  std::string __str__() const override {
    return "<" + cls_->__name__() + " instance>";
  }
  std::string __name__() const override {
    return cls_->__name__();
  }

private:
  std::shared_ptr<ClassObject>                    cls_;
  std::unordered_map<std::string,
                     std::shared_ptr<Object>>    fields_;
};

# ```
# 

```./vm/obj/Integer.cpp
#include "Integer.hpp"
#include "Float.hpp"
#include "Boolean.hpp"
#include "String.hpp"
#include <memory>

Integer::Integer(int64_t v) : value(v) {}

std::string Integer::__str__() const {
    return std::to_string(value);
}

bool Integer::__bool__() const {
    return value != 0;
}

std::string Integer::__name__() const {
    return "integer";
}

std::shared_ptr<Object> Integer::__add__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Integer>(value + p->value);
    }
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        return std::make_shared<Float>(static_cast<double>(value) + p->value);
    }
    if (const auto* p = dynamic_cast<const String*>(&o)) {
        return std::make_shared<String>(__str__() + p->value);
    }
    throw std::runtime_error("TypeError: integer + " + o.__name__());
}

std::shared_ptr<Object> Integer::__sub__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Integer>(value - p->value);
    }
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        return std::make_shared<Float>(static_cast<double>(value) - p->value);
    }
    throw std::runtime_error("TypeError: integer - " + o.__name__());
}

std::shared_ptr<Object> Integer::__mul__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Integer>(value * p->value);
    }
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        return std::make_shared<Float>(static_cast<double>(value) * p->value);
    }
    throw std::runtime_error("TypeError: integer * " + o.__name__());
}

std::shared_ptr<Object> Integer::__div__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        if (p->value == 0) throw std::runtime_error("ZeroDivisionError: integer / integer");
        return std::make_shared<Integer>(value / p->value);
    }
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        if (p->value == 0.0) throw std::runtime_error("ZeroDivisionError: integer / decimal");
        return std::make_shared<Float>(static_cast<double>(value) / p->value);
    }
    throw std::runtime_error("TypeError: integer / " + o.__name__());
}

std::shared_ptr<Object> Integer::__mod__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        if (p->value == 0) throw std::runtime_error("ZeroDivisionError: integer % integer");
        return std::make_shared<Integer>(value % p->value);
    }
    throw std::runtime_error("TypeError: integer % " + o.__name__());
}

std::shared_ptr<Object> Integer::__eq__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value == p->value);
    }
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        return std::make_shared<Boolean>(static_cast<double>(value) == p->value);
    }
    return std::make_shared<Boolean>(false);
}

std::shared_ptr<Object> Integer::__lt__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value < p->value);
    }
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        return std::make_shared<Boolean>(static_cast<double>(value) < p->value);
    }
    throw std::runtime_error("TypeError: integer < " + o.__name__());
}

std::shared_ptr<Object> Integer::__gt__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value > p->value);
    }
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        return std::make_shared<Boolean>(static_cast<double>(value) > p->value);
    }
    throw std::runtime_error("TypeError: integer > " + o.__name__());
}

std::shared_ptr<Object> Integer::__le__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value <= p->value);
    }
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        return std::make_shared<Boolean>(static_cast<double>(value) <= p->value);
    }
    throw std::runtime_error("TypeError: integer <= " + o.__name__());
}

std::shared_ptr<Object> Integer::__ge__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value >= p->value);
    }
    if (const auto* p = dynamic_cast<const Float*>(&o)) {
        return std::make_shared<Boolean>(static_cast<double>(value) >= p->value);
    }
    throw std::runtime_error("TypeError: integer >= " + o.__name__());
}
std::shared_ptr<Object> Integer::__or__(const Object& o) const {
    return std::make_shared<Boolean>(__bool__() || o.__bool__());
}
std::shared_ptr<Object> Integer::__and__(const Object& o) const {
    return std::make_shared<Boolean>(__bool__() && o.__bool__());
}
std::shared_ptr<Object> Integer::__not__() const {
    return std::make_shared<Boolean>(!__bool__());
}

# ```
# 

```./vm/obj/Boolean.cpp
#include "Boolean.hpp"
#include <string>
#include "Object.hpp"

Boolean::Boolean(bool v) : value(v) {}

std::string Boolean::__str__() const {
    return value ? "true" : "false";
}

bool Boolean::__bool__() const {
    return value;
}

std::string Boolean::__name__() const {
    return "boolean";
}

std::shared_ptr<Object> Boolean::__eq__(const Object& o) const {
    return std::make_shared<Boolean>(o.__bool__() == value);
}

std::shared_ptr<Object> Boolean::__and__(const Object& o) const {
    return std::make_shared<Boolean>(value && o.__bool__());
}

std::shared_ptr<Object> Boolean::__or__(const Object& o) const {
    return std::make_shared<Boolean>(value || o.__bool__());
}

std::shared_ptr<Object> Boolean::__not__() const {
    return std::make_shared<Boolean>(!value);
}

# ```
# 

```./vm/obj/NaN.hpp
#pragma once
#include "Object.hpp"

class NaN : public Object {
public:
    std::string __str__() const override;
    bool __bool__() const override;
    double __double__() const override;
    int64_t __int__() const override;
    std::string __name__() const override;

    static std::shared_ptr<NaN> instance();
};

# ```
# 

```./vm/obj/BuiltinFn.cpp
#include "BuiltinFn.hpp"

BuiltinFn::BuiltinFn(FnType fn, std::string name)
    : fn_(std::move(fn)), name_(std::move(name))
{}

std::string BuiltinFn::__str__() const {
    return "<builtin function " + name_ + ">";
}

bool BuiltinFn::__bool__() const {
    return true;
}

std::string BuiltinFn::__name__() const {
    return name_;
}

bool BuiltinFn::invoke(Process& p) const {
    // Delegate to the stored C++ function
    return fn_(p);
}

# ```
# 

```./vm/obj/RegEx.cpp
#include "RegEx.hpp"

RegEx::RegEx(const std::string& pattern, const std::set<char>& f)
    : String(pattern), flags(f) {}

std::string RegEx::__name__() const {
    return "string::regex";
}

bool RegEx::has_flag(char flag) const {
    return flags.find(flag) != flags.end();
}

# ```
# 

```./vm/obj/FunctionObject.hpp
#pragma once

#include <string>
#include <memory>
#include "../core/Process.hpp"
#include "Object.hpp"

class FunctionObject : public Object {
public:
    // Free function constructor
    FunctionObject(std::string label, size_t arity);

    // Bound method constructor (captures a receiver)
    FunctionObject(std::string label, size_t arity, std::shared_ptr<Object> receiver);

    // Object protocol
    std::string __str__()   const override;
    bool        __bool__()  const override;
    std::string __name__()  const override;

    // Actually invoke this function in the VM
    bool invoke(Process& p) const;

private:
    std::string                 label_;     // label to jump to
    size_t                      arity_;     // how many args to pop
    std::shared_ptr<Object>     receiver_;  // if non-null, bind as "this"
};

# ```
# 

```./vm/core/Memory.cpp
#include "Memory.hpp"
#include "string"
#include "../obj/Nix.hpp"

void Memory::declare(const std::string& n) {
    if (mem.find(n) != mem.end())
        throw std::runtime_error("Already declared: " + n);
    mem[n] = std::make_shared<Nix>();
}
void Memory::set(const std::string& n, const std::shared_ptr<Object>& v) {
    mem[n] = v;
}
void Memory::remove(const std::string& n) {
    auto it = mem.find(n);
    if (it == mem.end())
        throw std::runtime_error("Cannot erase undeclared variable: " + n);
    mem.erase(it);
}
const std::shared_ptr<Object>& Memory::get(const std::string& n) const {
    auto it = mem.find(n);
    if (it == mem.end())
        throw std::runtime_error("Undefined var: " + n);
    return it->second;
}
bool Memory::has(const std::string& n) const {
    auto it = mem.find(n);
    return it != mem.end();
}

# ```
# 

```./vm/core/opmap.hpp
#pragma once
#include <unordered_map>
#include <string>
#include "Opcode.hpp"

extern const std::unordered_map<std::string, Opcode> opmap;

extern const Opcode get_opcode_from_string(const std::string& opcode);
extern const std::string get_string_from_opcode(Opcode opcode);

# ```
# 

```./vm/core/Bytecode.cpp
#include "Bytecode.hpp"
#include "opmap.hpp"

std::string Bytecode::toString() {
    std::string opname = "UNDEFINED_OP_CODE";
    for (auto kv : opmap) {
        if (kv.second == opcode) {
            opname = kv.first;
        }
    }

    std::string out = "(" + opname + ",";
    for (auto o : operand) {
        out += o + ",";
    }

    return out.substr(0, out.size() - 1) + ")";
}

# ```
# 

```./vm/core/Process.cpp
#include <iostream>
#include "Process.hpp"
#include "Bytecode.hpp"
#include "../exec/exec.hpp"
#include "../helpers/exec_step.hpp"
#include "../obj/ClassObject.hpp"
#include "../obj/Integer.hpp"
#include "../obj/Float.hpp"

void Process::execute() {
    // Collect all labels
    for (size_t c = 0; c < module.size(); ++c) {
        const Bytecode& b = module[c];
        if (b.opcode == OP_LABEL) {
            const std::string& name = b.operand.at(0);

            // Skip label if invalid
            if (name.empty()) {
                std::cerr << "Invalid label at index " << c << std::endl;
                exit(3);
            }

            // Register the label â†’ next instruction
            labels.set(name, c + 1);
        }
    }

    if (!labels.exists("main")) {
        err("Expected .main label. None found.");
        return;
    }

    pc = labels.get("main");
    while (!completed && !broken) {
        exec_step(*this);
    }
}

void Process::register_globals() {
    // Integer(...)
    global_memory.declare("Integer");
    global_memory.set("Integer",
      std::make_shared<ClassObject>(
        "Integer", /*arity=*/1,
        [](auto const& args) {
          // mimic Pythonâ€™s int(obj): use the Objectâ€™s __int__()
          return std::make_shared<Integer>( args[0]->__int__() );
        }
      )
    );

    // Float(...)
    global_memory.declare("Float");
    global_memory.set("Float",
      std::make_shared<ClassObject>(
        "Float", /*arity=*/1,
        [](auto const& args) {
          return std::make_shared<Float>( args[0]->__double__() );
        }
      )
    );
}

void Process::err(const std::string& message, const int& code) {
    std::cerr << "An error occured during the bytecode execution." << std::endl << "\tDuring process count: " << pc << std::endl << "Error: " << message << std::endl;
    completed = true;
    broken = true;
}

void Process::err(const std::string& message) {
    err(message, -1);
}

# ```
# 

```./vm/core/SectionTable.hpp
#pragma once
#include <unordered_map>
#include <string>

struct SectionTable {
    std::unordered_map<std::string, size_t> sections;
};

# ```
# 

```./vm/core/EnvStack.hpp
#pragma once
#include <vector>
#include <memory>
#include <string>
#include "../../vm/core/Memory.hpp"
#include "../../vm/obj/Object.hpp"

/**
 * EnvStack manages a stack of Memory scopes
 * for local variable environments (e.g., inside functions).
 */
class EnvStack {
public:
    EnvStack();

    // Scope management
    void push_scope();
    void pop_scope();

    // Variable operations
    void declare(const std::string& name);
    bool set(const std::string& name, const std::shared_ptr<Object>& value);
    std::shared_ptr<Object> get(const std::string& name) const;
    bool has(const std::string& name) const;
    bool set_or_declare(const std::string& name,
                        const std::shared_ptr<Object>& value);

    // Utility
    bool empty() const;
    size_t size() const;

private:
    std::vector<Memory> scopes;
};

# ```
# 

```./vm/core/OperandStack.cpp
#include "OperandStack.hpp"

void OperandStack::push(const std::shared_ptr<Object>& v) {
    nodes.push_back(v);
}
std::shared_ptr<Object> OperandStack::pop() {
    if (nodes.empty()) throw std::runtime_error("OperandStack underflow in OperandStack::pop()");
    auto v = nodes.back();
    nodes.pop_back();
    return v;
}
bool OperandStack::empty() const {
    return nodes.empty();
}
size_t OperandStack::size() const {
    return nodes.size();
}
std::shared_ptr<Object> OperandStack::back() const {
    return nodes.back();
}

# ```
# 

```./vm/core/CallStack.hpp
#pragma once
#include <vector>

struct CallStack {
    std::vector<size_t> stack;
    void push(const size_t);
    size_t pop();
    bool   empty() const;
    size_t size() const;
    size_t back() const;
};

# ```
# 

```./vm/core/LabelMap.cpp
#include "LabelMap.hpp"

void LabelMap::set(std::string label, size_t pc) {
    labels[label] = pc;
}

size_t LabelMap::get(std::string label) {
    return labels[label];
}

bool LabelMap::exists(std::string label) {
    return labels.contains(label);
}

# ```
# 

```./vm/core/Opcode.hpp
#pragma once

enum Opcode {
    OP_PUSH = 0,
    OP_POP, OP_DUP, OP_SWAP, OP_DEL,
    OP_DECL, OP_SET, OP_GET,
    OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MOD,
    OP_EQ, OP_LT, OP_GT, OP_AND, OP_OR, OP_NOT,
    OP_JMP, OP_JZ, OP_JNZ,
    OP_LABEL, OP_CALL, OP_RET, OP_END,
    OP_WRITE, OP_FLUSH, OP_DUMP,
    OP_IN, OP_FREAD, OP_FWRITE, OP_EXIT,
    OP_RAND, OP_TIME, OP_SLEEP, OP_CAST,
    OP_TYPE, NOP, OP_ACCESS,

    OP_LIST_NEW, OP_LIST_INS, OP_LIST_SET,
    OP_LIST_GET, OP_LIST_LEN
};

# ```
# 

```./vm/core/TypeTable.hpp
#include <string>
#include <unordered_map>
struct TypeTable {
    std::unordered_map<std::string, std::string> types;
    void set(const std::string& name, const std::string& type);
    std::string get(const std::string& name) const;
    bool has(const std::string& name) const;
};

# ```
# 

```./vm/core/Buffer.cpp
#include <string>
#include <iostream>
#include "Buffer.hpp"

void Buffer::write(const std::string& s) {
    out << s;
}
void Buffer::dump() const {
    std::cout << out.str();
}
void Buffer::flush() {
    out.str("");
    out.clear();
    std::cout << std::flush;
}

# ```
# 

```./vm/core/OperandStack.hpp
#pragma once
#include <vector>
#include "../obj/Object.hpp"

struct OperandStack {
    std::vector<std::shared_ptr<Object>> nodes;
    void push(const std::shared_ptr<Object>&);
    std::shared_ptr<Object> pop();
    bool empty() const;
    size_t size()  const;
    std::shared_ptr<Object> back() const;
};

# ```
# 

```./vm/core/CallStack.cpp
#include "CallStack.hpp"

void CallStack::push(const size_t v) {
    stack.push_back(v);
}
size_t CallStack::pop() {
    if (stack.empty()) throw std::runtime_error("CallStack underflow");
    auto v = stack.back();
    stack.pop_back();
    return v;
}
bool CallStack::empty() const {
    return stack.empty();
}
size_t CallStack::size() const {
    return stack.size();
}
size_t CallStack::back() const {
    return stack.back();
}

# ```
# 

```./vm/core/LabelMap.hpp
#include <unordered_map>
#include <string>

struct LabelMap {
    std::unordered_map<std::string, size_t> labels = {};
    void set(std::string label, size_t pc);

    size_t get(std::string label);

    bool exists(std::string label);
};

# ```
# 

```./vm/core/TypeTable.cpp
#include "TypeTable.hpp"
std::unordered_map<std::string, std::string> types;

void TypeTable::set(const std::string& name, const std::string& type) {
    types[name] = type;
}

std::string TypeTable::get(const std::string& name) const {
    auto it = types.find(name);
    if (it == types.end()) return "any";
    return it->second;
}

bool TypeTable::has(const std::string& name) const {
    return types.find(name) != types.end();
}

# ```
# 

```./vm/core/Buffer.hpp
#pragma once
#include <string>
#include <sstream>

struct Buffer {
    std::ostringstream out;
    void write (const std::string&);
    void dump  () const;
    void flush ();
};

# ```
# 

```./vm/core/Memory.hpp
#pragma once
#include <unordered_map>
#include "../obj/Object.hpp"

struct Memory {
    std::unordered_map<std::string, std::shared_ptr<Object>> mem;
    void declare(const std::string&);
    void set    (const std::string&, const std::shared_ptr<Object>&);
    void remove (const std::string&);
    bool has    (const std::string&) const;
    const std::shared_ptr<Object>& get(const std::string&) const;
};

# ```
# 

```./vm/core/opmap.cpp
#include "opmap.hpp"
#include <stdexcept>

const std::unordered_map<std::string, Opcode> opmap = {
    {"PUSH", OP_PUSH}, {"POP", OP_POP}, {"DUP", OP_DUP}, {"SWAP", OP_SWAP},
    {"DEL", OP_DEL}, {"DECL", OP_DECL}, {"SET", OP_SET}, {"GET", OP_GET},
    {"ADD", OP_ADD}, {"SUB", OP_SUB}, {"MUL", OP_MUL}, {"DIV", OP_DIV},
    {"MOD", OP_MOD}, {"EQ", OP_EQ}, {"LT", OP_LT}, {"GT", OP_GT},
    {"AND", OP_AND}, {"OR", OP_OR}, {"NOT", OP_NOT}, {"JMP", OP_JMP},
    {"JZ", OP_JZ}, {"JNZ", OP_JNZ}, {"CALL", OP_CALL}, {"RET", OP_RET},
    {"END", OP_END}, {"WRITE", OP_WRITE}, {"FLUSH", OP_FLUSH}, {"DUMP", OP_DUMP},
    {"IN", OP_IN}, {"FREAD", OP_FREAD}, {"FWRITE", OP_FWRITE}, {"EXIT", OP_EXIT},
    {"RAND", OP_RAND}, {"TIME", OP_TIME}, {"SLEEP", OP_SLEEP}, {"NOP", NOP},
    {"TYPE", OP_TYPE}, {"CAST", OP_CAST}, {"LABEL", OP_LABEL},
    {"LIST_NEW", OP_LIST_NEW}, {"LIST_INS", OP_LIST_INS},
    {"LIST_GET", OP_LIST_GET}, {"LIST_SET", OP_LIST_SET}, {"LIST_LEN", OP_LIST_LEN},
    {"ACCESS", OP_ACCESS}
};


// Define reverse mappings from Opcode â†’ string
const std::unordered_map<Opcode, std::string> strmap = [] {
    std::unordered_map<Opcode, std::string> rev;
    for (const auto& [key, val] : opmap) {
        rev[val] = key;
    }
    return rev;
}();

// Lookup function: string â†’ Opcode
const Opcode get_opcode_from_string(const std::string& opcode) {
    auto it = opmap.find(opcode);
    if (it != opmap.end())
        return it->second;
    throw std::invalid_argument("Unknown opcode: " + opcode);
}

// Lookup function: Opcode â†’ string
const std::string get_string_from_opcode(Opcode opcode) {
    auto it = strmap.find(opcode);
    if (it != strmap.end())
        return it->second;
    return "UNKNOWN";
}

# ```
# 

```./vm/core/Bytecode.hpp
#pragma once
#include <string>
#include <vector>
#include "Opcode.hpp"

struct Bytecode {
    Opcode opcode;
    std::vector<std::string> operand;
    Bytecode(Opcode op, std::vector<std::string> o = {}) : opcode(op), operand(std::move(o)) {}
    std::string toString();
};

# ```
# 

```./vm/core/Process.hpp
#pragma once
#include <iostream>
#include <string>
#include <vector>
#include "Buffer.hpp"
#include "Bytecode.hpp"
#include "OperandStack.hpp"
#include "SectionTable.hpp"
#include "LabelMap.hpp"
#include "Memory.hpp"
#include "CallStack.hpp"
#include "EnvStack.hpp"

struct Process {
    std::vector<Bytecode>     module               ;
    Buffer                    buffer               ;
    OperandStack              stack                ;
    SectionTable              sections             ;
    LabelMap                  labels               ;
    Memory                    global_memory        ;
    size_t                    pc            = 0    ;
    EnvStack                  env_stack            ;
    CallStack                 callstack            ;
    bool                      completed     = false;
    bool                      broken        = false;

    Process(std::vector<Bytecode> m) : module(std::move(m)) {
        env_stack.push_scope();      // â† global-scope frame
    };

    void register_globals();

    /**
     * Begins the process
     */
    void execute();

    void err(const std::string& message, const int& code);
    void err(const std::string& message);
};

# ```
# 

```./vm/core/EnvStack.cpp
#include "EnvStack.hpp"
#include <stdexcept>

// --- Constructor ---
EnvStack::EnvStack() = default;

// --- Scope management ---
void EnvStack::push_scope() {
    scopes.emplace_back();
}

void EnvStack::pop_scope() {
    if (scopes.empty()) {
        throw std::runtime_error("EnvStack: Cannot pop from an empty scope stack.");
    }
    scopes.pop_back();
}

// --- Variable operations ---
void EnvStack::declare(const std::string& name) {
    if (scopes.empty()) {
        throw std::runtime_error("EnvStack: No local scope to declare variable '" + name + "'.");
    }
    scopes.back().declare(name);
}

bool EnvStack::set(const std::string& name, const std::shared_ptr<Object>& value) {
    for (auto it = scopes.rbegin(); it != scopes.rend(); ++it) {
        if (it->has(name)) {
            it->set(name, value);
            return true;
        }
    }
    return false; // Not found in any local scope
}

std::shared_ptr<Object> EnvStack::get(const std::string& name) const {
    for (auto it = scopes.rbegin(); it != scopes.rend(); ++it) {
        if (it->has(name)) {
            return it->get(name);
        }
    }
    throw std::runtime_error("EnvStack: Undefined variable '" + name + "'.");
}

bool EnvStack::has(const std::string& name) const {
    for (auto it = scopes.rbegin(); it != scopes.rend(); ++it) {
        if (it->has(name)) {
            return true;
        }
    }
    return false;
}


bool EnvStack::set_or_declare(const std::string& n,
                              const std::shared_ptr<Object>& v) {
    if (set(n, v)) return true;
    if (!scopes.empty()) { scopes.back().declare(n); scopes.back().set(n,v); }
    return true;
}

// --- Utility ---
bool EnvStack::empty() const {
    return scopes.empty();
}

size_t EnvStack::size() const {
    return scopes.size();
}

# ```
# 

```./vm/exec/RET.cpp
#include "exec.hpp"
#include "RET.hpp"
bool exec::RET(Process& p) {
     if (p.callstack.empty()) {
        p.err("Return without call");
        return false;
     }

     if (p.stack.empty()) {
        p.err("Attempted to return from empty stack");
        return false;
     }

     p.env_stack.pop_scope();    // drop calleeâ€™s locals
     p.pc = p.callstack.pop();
     return true;
 }

# ```
# 

```./vm/exec/CAST.hpp
#pragma once
#include "exec.hpp"
#include "../obj/ClassObject.hpp"
bool exec::CAST(Process& p);

# ```
# 

```./vm/exec/WRITE.cpp
#include "WRITE.hpp"
#include "exec.hpp"
bool exec::WRITE(Process& p) {
    p.buffer.write(p.stack.pop()->__str__());
    return true;
}

# ```
# 

```./vm/exec/JNZ.hpp
#pragma once
#include "exec.hpp"
bool exec::JNZ(Process& p);

# ```
# 

```./vm/exec/ACCESS.hpp
#pragma once
#include "./exec.hpp"
#include "./../obj/String.hpp"
#include "./../obj/Object.hpp"

bool exec::ACCESS(Process& p);

# ```
# 

```./vm/exec/BINARY_OP.hpp
#pragma once
#include "../core/Process.hpp"

namespace exec {
    bool ADD(Process& p);
    bool SUB(Process& p);
    bool MUL(Process& p);
    bool DIV(Process& p);
    bool MOD(Process& p);
    bool EQ(Process& p);
    bool GT(Process& p);
    bool LT(Process& p);
    bool OR(Process& p);
    bool AND(Process& p);
}

# ```
# 

```./vm/exec/LIST_NEW.hpp
#pragma once
#include "../obj/List.hpp"
#include "exec.hpp"

bool exec::LIST_NEW(Process& p);

# ```
# 

```./vm/exec/GET.hpp
#pragma once
#include "exec.hpp"
bool exec::GET(Process& p);

# ```
# 

```./vm/exec/LIST_SET.hpp
#pragma once
#include "../obj/List.hpp"
#include "../obj/Integer.hpp"
#include "exec.hpp"

bool exec::LIST_SET(Process& p);

# ```
# 

```./vm/exec/LIST_INS.hpp
#pragma once
#include "../obj/List.hpp"
#include "../obj/Integer.hpp"
#include "exec.hpp"

bool exec::LIST_INS(Process& p);

# ```
# 

```./vm/exec/LIST_LEN.cpp
#include "LIST_LEN.hpp"

bool exec::LIST_LEN(Process& p) {
    auto list = p.stack.pop();
    auto list_obj = std::dynamic_pointer_cast<List>(list);
    p.stack.push(std::make_shared<Integer>(list_obj->size()));
    return true;
}

# ```
# 

```./vm/exec/DUP.cpp
#include "DUP.hpp"
#include "exec.hpp"
bool exec::DUP(Process& p)  {
    if (p.stack.empty()) return true;
    p.stack.push(p.stack.back());
    return true;
}

# ```
# 

```./vm/exec/DUMP.hpp
#pragma once
#include "exec.hpp"
bool exec::DUMP(Process& p);

# ```
# 

```./vm/exec/JMP.hpp
#pragma once
#include "exec.hpp"
bool exec::JMP(Process& p);

# ```
# 

```./vm/exec/TYPE.hpp
#pragma once
#include <string>
#include "exec.hpp"
#include "../helpers/is_valid_identifier.hpp"
bool exec::TYPE(Process& p);

# ```
# 

```./vm/exec/TIME.hpp
#pragma once
#include "exec.hpp"
bool exec::TIME(Process& p);

# ```
# 

```./vm/exec/DEL.cpp
#include "DEL.hpp"
#include "exec.hpp"
bool exec::DEL(Process& p) {
    const auto& b = p.module[p.pc];
    if (p.env_stack.has(b.operand.at(0)))
        p.env_stack.pop_scope();            // optional: or implement remove()
    else
        p.global_memory.remove(b.operand.at(0));
    return true;
}

# ```
# 

```./vm/exec/LABEL.hpp
#pragma once
#include "exec.hpp"
bool exec::LABEL(Process& p);

# ```
# 

```./vm/exec/SETFIELD.hpp
#pragma once
#include "exec.hpp"
#include "../obj/String.hpp"

bool exec::SETFIELD(Process& p);

# ```
# 

```./vm/exec/RAND.hpp
#pragma once
#include "exec.hpp"
bool exec::RAND(Process& p);

# ```
# 

```./vm/exec/SWAP.cpp
#include "SWAP.hpp"
#include "exec.hpp"
bool exec::SWAP(Process& p) {
    if (p.stack.size() < 2) return true;
    auto a = p.stack.pop();
    auto b = p.stack.pop();
    p.stack.push(a);
    p.stack.push(b);
    return true;
}

# ```
# 

```./vm/exec/SET.cpp
#include "SET.hpp"
#include "exec.hpp"

bool exec::SET(Process& p) {
    const auto& b = p.module[p.pc];

    if (b.operand.empty()) {
        p.err("Missing operand in SET");
        return false;
    }

    const std::string& name = b.operand.at(0);

    if (p.stack.empty()) {
        p.err("SET failed: stack is empty");
        return false;
    }

    std::shared_ptr<Object> val = p.stack.back();

    // Try setting in env_stack first
    if (!p.env_stack.set(name, val)) {
        // If it doesn't exist in env_stack, set in global memory
        p.global_memory.set(name, val);
    }

    p.stack.pop();
    return true;
}

# ```
# 

```./vm/exec/LIST_GET.cpp
#include "LIST_GET.hpp"

bool exec::LIST_GET(Process& p) {
    auto index = std::dynamic_pointer_cast<Integer>(p.stack.pop());
    auto list = std::dynamic_pointer_cast<List>(p.stack.pop());
    p.stack.push(list->get_at(index));
    return true;
}

# ```
# 

```./vm/exec/EXIT.cpp
#include "EXIT.hpp"
#include "exec.hpp"
bool exec::EXIT(Process& p)  {
    p.completed = true;
    return true;
}

# ```
# 

```./vm/exec/CALL.cpp
#include <string>
#include "CALL.hpp"
#include "exec.hpp"
bool exec::CALL(Process& p) {
    const auto& b = p.module[p.pc];
    // Peek at whatâ€™s on the stack
    auto maybeFn = p.stack.pop();
    if (auto fnObj = std::dynamic_pointer_cast<FunctionObject>(maybeFn)) {
        // Let the function object handle binding new scope, args, etc.
        fnObj->invoke(p);
        return true;
    }

    if (b.operand.size() != 1) {
        p.err("CALL expects 1 operand, got " + std::to_string(b.operand.size()));
        return false;
    }
    const auto& nm = b.operand[0];
    if (!p.labels.exists(nm)) {
        p.err("Unknown label in CALL: '" + nm + "'");
        return false;
    }

    // 1) push a new local scope
    p.env_stack.push_scope();

    // 2) save return address (next instruction)
    p.callstack.push(p.pc + 1);

    // 3) jump into the function
    p.pc = p.labels.get(nm);
    return true;
}

# ```
# 

```./vm/exec/PUSH.cpp
#include "PUSH.hpp"
#include "../helpers/parse_literal.hpp"
#include "exec.hpp"
bool exec::PUSH(Process& p) {
    const auto& b = p.module[p.pc];
    p.stack.push(parse_literal(b.operand.at(0)));
    return true;
}

# ```
# 

```./vm/exec/POP.cpp
#include "POP.hpp"
#include "exec.hpp"

bool exec::POP(Process& p) {
    const auto& b = p.module[p.pc];
    if (p.stack.empty()) {
        p.err("Attempted to pop from an empty stack");
        return false;
    }

    auto value = p.stack.pop();
    if (!p.env_stack.set(b.operand.at(0), value)) {
        p.global_memory.set(b.operand.at(0), value);
    }
    return true;
}

# ```
# 

```./vm/exec/UNARY_OP.hpp
#pragma once
#include "../core/Process.hpp"

namespace exec {
    bool NOT(Process& p);
}

# ```
# 

```./vm/exec/FLUSH.cpp
#include "FLUSH.hpp"
#include "exec.hpp"
bool exec::FLUSH(Process& p) {
    p.buffer.flush();
    return true;
}

# ```
# 

```./vm/exec/JZ.cpp
#include <string>
#include "JZ.hpp"
#include "exec.hpp"
bool exec::JZ(Process& p) {
    auto cond = p.stack.pop();
    const auto& nm = p.module[p.pc].operand.at(0);
    if (!cond->__bool__()) {
        if (!p.labels.exists(nm)) {
            p.err("Unknown label in JZ: '" + nm + "'");
            return false;
        }
        p.pc = p.labels.get(nm);
    }
    return true;
}

# ```
# 

```./vm/exec/DECL.cpp
#include "DECL.hpp"
#include "exec.hpp"
bool exec::DECL(Process& p) {
    const auto& b = p.module[p.pc];
    if (!p.env_stack.empty())
        p.env_stack.declare(b.operand.at(0));
    else
        p.global_memory.declare(b.operand.at(0));
    return true;
}

# ```
# 

```./vm/exec/DEL.hpp
#pragma once
#include "exec.hpp"
bool exec::DEL(Process& p);

# ```
# 

```./vm/exec/LABEL.cpp
#include <string>
#include "LABEL.hpp"
#include "exec.hpp"
#include "../helpers/is_valid_identifier.hpp"

// New helper for namespaced label validation
bool is_valid_namespaced_identifier(const std::string& name) {
    // Split by '.'
    size_t start = 0;
    while (start < name.size()) {
        size_t dot = name.find('.', start);
        std::string part = name.substr(start, dot - start);
        if (!is_valid_identifier(part))
            return false;
        if (dot == std::string::npos)
            break;
        start = dot + 1;
    }
    return true;
}

bool exec::LABEL(Process& p) {
    const auto& b = p.module[p.pc];
    std::string name = b.operand.at(0);

    // No longer require leading '.', but ensure name is valid
    if (!is_valid_namespaced_identifier(name)) {
        p.err("Invalid label name: " + name);
        return false;
    }

    // Store label exactly as-is (e.g., "Math.Linear.dot")
    p.labels.set(name, p.pc + 1);
    return true;
}

# ```
# 

```./vm/exec/RAND.cpp
#include <random>
#include "../obj/Float.hpp"
#include "RAND.hpp"
#include "exec.hpp"
bool exec::RAND(Process& p) {
    static std::mt19937 rng{std::random_device{}()};
    std::uniform_real_distribution<double> dist(0.0,1.0);
    p.stack.push(std::make_shared<Float>(dist(rng)));
    return true;
}

# ```
# 

```./vm/exec/SWAP.hpp
#pragma once
#include "exec.hpp"
bool exec::SWAP(Process& p);

# ```
# 

```./vm/exec/SETFIELD.cpp
#include "SETFIELD.hpp"

bool exec::SETFIELD(Process& p) {
  // pop the new value
  auto val = p.stack.pop();
  // pop the key string
  auto keyObj = p.stack.pop();
  auto keyStr = std::dynamic_pointer_cast<String>(keyObj);
  if (!keyStr) throw std::runtime_error("SETFIELD: expected string key");

  // pop the receiver
  auto receiver = p.stack.pop();

  // store it
  receiver->setField(keyStr->value, val);
  return true;
}

# ```
# 

```./vm/exec/SET.hpp
#pragma once
#include "exec.hpp"
bool exec::SET(Process& p);

# ```
# 

```./vm/exec/LIST_GET.hpp
#pragma once
#include "../obj/List.hpp"
#include "../obj/Integer.hpp"
#include "exec.hpp"

bool exec::LIST_GET(Process& p);

# ```
# 

```./vm/exec/EXIT.hpp
#pragma once
#include "exec.hpp"
bool exec::EXIT(Process& p);

# ```
# 

```./vm/exec/CALL.hpp
#pragma once
#include "exec.hpp"
#include "../obj/FunctionObject.hpp"
bool exec::CALL(Process& p);

# ```
# 

```./vm/exec/POP.hpp
#pragma once
#include "exec.hpp"
bool exec::POP(Process& p);

# ```
# 

```./vm/exec/PUSH.hpp
#pragma once
#include "exec.hpp"
bool exec::PUSH(Process& p);

# ```
# 

```./vm/exec/UNARY_OP.cpp
#include "UNARY_OP.hpp"
#include <stdexcept>

#define UNARY_OP(name, method)                     \
bool exec::name(Process& p) {                      \
    if (p.stack.empty())                           \
        throw std::runtime_error(#name " underflow"); \
    auto val = p.stack.pop();                      \
    p.stack.push(val->method());                   \
    return true;                                   \
}

UNARY_OP(NOT, __not__)

# ```
# 

```./vm/exec/exec.hpp
#pragma once
#include "../core/Process.hpp"

namespace exec {
    // VM opcode handlers
    bool LABEL(Process&);
    bool PUSH(Process&);
    bool POP(Process&);
    bool DUP(Process&);
    bool DECL(Process&);
    bool TYPE(Process&);
    bool CAST(Process&);
    bool SWAP(Process&);
    bool SET(Process&);
    bool GET(Process&);
    bool DEL(Process&);
    bool WRITE(Process&);
    bool FLUSH(Process&);
    bool DUMP(Process&);
    bool ADD(Process&);
    bool SUB(Process&);
    bool MUL(Process&);
    bool DIV(Process&);
    bool MOD(Process&);
    bool EQ(Process&);
    bool GT(Process&);
    bool LT(Process&);
    bool OR(Process&);
    bool AND(Process&);
    bool NOT(Process&);
    bool JMP(Process&);
    bool JNZ(Process&);
    bool JZ(Process&);
    bool EXIT(Process&);
    bool RET(Process&);
    bool CALL(Process&);
    bool RAND(Process&);
    bool TIME(Process&);
    bool LIST_NEW(Process&);
    bool LIST_GET(Process&);
    bool LIST_SET(Process&);
    bool LIST_LEN(Process&);
    bool LIST_INS(Process&);
    bool ACCESS(Process&);
    bool SETFIELD(Process&);
}

# ```
# 

```./vm/exec/FLUSH.hpp
#pragma once
#include "exec.hpp"
bool exec::FLUSH(Process& p);

# ```
# 

```./vm/exec/DECL.hpp
#pragma once
#include "exec.hpp"
bool exec::DECL(Process& p);

# ```
# 

```./vm/exec/JZ.hpp
#pragma once
#include "exec.hpp"
bool exec::JZ(Process& p);

# ```
# 

```./vm/exec/WRITE.hpp
#pragma once
#include "exec.hpp"
bool exec::WRITE(Process& p);

# ```
# 

```./vm/exec/CAST.cpp
#include "CAST.hpp"
bool exec::CAST(Process &p) {
    // 1) Which type?  (e.g. "Integer")
    auto typeName = p.module[p.pc].operand.at(0);

    // 2) Pop the value to convert
    auto val = p.stack.pop();

    // 3) Fetch the ClassObject from global memory
    auto clsObj = p.global_memory.get(typeName);
    auto co     = std::dynamic_pointer_cast<ClassObject>(clsObj);
    if (!co) throw std::runtime_error("CAST: unknown type " + typeName);

    // 4) Push the argument back and invoke the â€œconstructorâ€
    p.stack.push(val);
    co->invoke(p);

    return true;
}

# ```
# 

```./vm/exec/RET.hpp
#pragma once
#include "exec.hpp"
bool exec::RET(Process& p);

# ```
# 

```./vm/exec/JNZ.cpp
#include <string>
#include "JNZ.hpp"
#include "exec.hpp"

bool exec::JNZ(Process& p) {
    auto cond = p.stack.pop();
    const auto& nm = p.module[p.pc].operand.at(0);

    if (!cond->__bool__()) {
        if (!p.labels.exists(nm)) {
            p.err("Unknown label in JNZ: '" + nm + "'");
            return false;
        }
        p.pc = p.labels.get(nm);
    }

    return true;
}

# ```
# 

```./vm/exec/BINARY_OP.cpp
#include "BINARY_OP.hpp"
#include <stdexcept>

// Define macro locally to this translation unit
#define BINARY_OP(name, method)                     \
bool exec::name(Process& p) {                       \
    if (p.stack.size() < 2)                         \
        throw std::runtime_error(#name " underflow"); \
    auto rhs = p.stack.pop();                       \
    auto lhs = p.stack.pop();                       \
    p.stack.push(lhs->method(*rhs));                \
    return true;                                    \
}

BINARY_OP(ADD,   __add__)
BINARY_OP(SUB,   __sub__)
BINARY_OP(MUL,   __mul__)
BINARY_OP(DIV,   __div__)
BINARY_OP(MOD,   __mod__)
BINARY_OP(EQ,    __eq__)
BINARY_OP(GT,    __gt__)
BINARY_OP(LT,    __lt__)
BINARY_OP(OR,    __or__)
BINARY_OP(AND,    __and__)
#undef BINARY_OP

# ```
# 

```./vm/exec/ACCESS.cpp
#include "ACCESS.hpp"
#include "../obj/String.hpp"
#include <stdexcept>
#include <memory>

bool exec::ACCESS(Process& p) {
    // 1) pop the property name (must be a String)
    auto keyObj = p.stack.pop();
    auto keyStr = std::dynamic_pointer_cast<String>(keyObj);
    if (!keyStr) {
        throw std::runtime_error("ACCESS: expected string as property name");
    }
    std::string key = keyStr->value;

    // 2) pop the target object
    auto target = p.stack.pop();

    // 3) method lookup: if the object has a method by this name, bind it
    if (target->hasMethod(key)) {
        auto method = target->getMethod(key);
        p.stack.push(method);
        return true;
    }

    // 4) field lookup: fall back to a plain field
    auto field = target->getField(key);
    if (!field) {
        throw std::runtime_error("ACCESS: field '" + key + "' not found");
    }
    p.stack.push(field);
    return true;
}

# ```
# 

```./vm/exec/LIST_NEW.cpp
#include "LIST_NEW.hpp"

bool exec::LIST_NEW(Process& p) {
    p.stack.push(std::make_shared<List>());
    return true;
}

# ```
# 

```./vm/exec/GET.cpp
#include "GET.hpp"
#include "../helpers/parse_literal.hpp"
#include "exec.hpp"

bool exec::GET(Process& p) {
    const auto& b = p.module[p.pc];

    if (b.operand.empty()) {
        p.err("Missing operand in GET");
        return false;
    }

    const std::string& name = b.operand.at(0);
    std::shared_ptr<Object> val;

    if (p.env_stack.has(name)) {
        val = p.env_stack.get(name);
    } else if (p.global_memory.has(name)) {
        val = p.global_memory.get(name);
    } else {
        p.err("GET failed: variable not found â†’ " + name);
        return false;
    }

    p.stack.push(val);
    return true;
}

# ```
# 

```./vm/exec/LIST_SET.cpp
#include "LIST_SET.hpp"

bool exec::LIST_SET(Process& p) {
    auto value = p.stack.pop();
    auto index = std::dynamic_pointer_cast<Integer>(p.stack.pop());
    auto list = std::dynamic_pointer_cast<List>(p.stack.pop());
    list->set_at(index, value);
    return true;
}

# ```
# 

```./vm/exec/LIST_INS.cpp
#include <iostream>
#include "LIST_INS.hpp"

bool exec::LIST_INS(Process& p) {
    auto index_obj = p.stack.pop();
    auto value = p.stack.pop();
    auto list_obj = p.stack.pop();

    auto index = std::dynamic_pointer_cast<Integer>(index_obj);
    auto list = std::dynamic_pointer_cast<List>(list_obj);

    if (!index) throw std::runtime_error("LIST_INS: index is not an Integer");
    if (!list)  throw std::runtime_error("LIST_INS: object is not a List");

    list->insert(index, value);
    p.stack.push(list);

    return true;
}

# ```
# 

```./vm/exec/LIST_LEN.hpp
#pragma once
#include "../obj/List.hpp"
#include "../obj/Integer.hpp"
#include "exec.hpp"

bool exec::LIST_LEN(Process& p);

# ```
# 

```./vm/exec/DUP.hpp
#pragma once
#include "exec.hpp"
bool exec::DUP(Process& p);

# ```
# 

```./vm/exec/DUMP.cpp
#include "DUMP.hpp"
#include "exec.hpp"
bool exec::DUMP(Process& p) {
    p.buffer.dump();
    return true;
}

# ```
# 

```./vm/exec/JMP.cpp
#include <string>
#include "JMP.hpp"
#include "exec.hpp"

bool exec::JMP(Process& p) {
    const auto& b = p.module[p.pc];

    // Ensure operand exists
    if (b.operand.empty()) {
        p.err("Missing operand in JMP instruction");
        return false;
    }

    std::string nm = b.operand.at(0);

    // Try to jump to label as-is
    if (!p.labels.exists(nm)) {
        p.err("Unknown label in JMP: '" + nm + "'");
        return false;
    }

    // Perform the jump
    p.pc = p.labels.get(nm);
    return true;
}

# ```
# 

```./vm/exec/TYPE.cpp
#include "TYPE.hpp"
bool exec::TYPE(Process& p) {
    Bytecode b = p.module.at(p.pc);
    if (b.operand.size() != 2) return false;

    auto& o1 = b.operand.at(0);
    auto& o2 = b.operand.at(1);

    if (
        o1.size() < 2 ||
        o1.at(0) != '$' ||
        !is_valid_identifier(o1.substr(1))
    ) return true;

    std::string iden = o1;
    std::string type = o2;

    return true;
}

# ```
# 

```./vm/exec/TIME.cpp
#include "../helpers/get_nanotime.hpp"
#include "../obj/Integer.hpp"
#include "exec.hpp"
bool exec::TIME(Process& p) {
    p.stack.push(std::make_shared<Integer>(get_nanotime()));
    return true;
}

# ```
# 

```./vm/helpers/parse_literal.hpp
#pragma once
#include <string>
#include <cctype>
#include <set>
#include <stdexcept>
#include <memory>
#include "../obj/Object.hpp"
#include "../obj/Nil.hpp"
#include "../obj/Nix.hpp"
#include "../obj/NaN.hpp"
#include "../obj/Boolean.hpp"
#include "../obj/String.hpp"
#include "../obj/Integer.hpp"
#include "../obj/Float.hpp"
#include "../obj/RegEx.hpp"
#include "../helpers/str_decode.hpp"

std::shared_ptr<Object> parse_literal(const std::string& tok);

# ```
# 

```./vm/helpers/str_encode.cpp
#include <string>

/**
 * Encodes a string into a literal form, escaping special characters
 * e.g. str_encode("hello\nworld") becomes "hello\\nworld"
 */
void str_encode(std::string& str) {
    std::string result;
    result.reserve(str.size() + 10); // reserve slightly more to avoid reallocations

    for (char ch : str) {
        switch (ch) {
            case '\n': result += "\\n"; break;
            case '\r': result += "\\r"; break;
            case '\t': result += "\\t"; break;
            case '\\': result += "\\\\"; break;
            case '"':  result += "\\\""; break;
            case '\'': result += "\\\'"; break;
            case '\0': result += "\\0"; break;
            default:
                // Only encode visible ASCII (printable characters)
                result += ch;
                break;
        }
    }

    str = std::move('"' + result + '"');
}

# ```
# 

```./vm/helpers/get_nanotime.hpp
#pragma once
#include <chrono>

int64_t get_nanotime();

# ```
# 

```./vm/helpers/split.cpp
#include <string>
#include <vector>
#include <sstream>
#include "split.hpp"
#include "trim.hpp"

std::vector<std::string> split(const std::string &s, char d)  {
    std::vector<std::string> out;
    std::istringstream ss(s);
    std::string item;
    while (std::getline(ss, item, d))
        if (!trim(item).empty())
            out.push_back(trim(item));
    return out;
}

# ```
# 

```./vm/helpers/unordered_map_to_string.cpp
#include "unordered_map_to_string.hpp"

template <typename K, typename V>
std::string unordered_map_to_string(const std::unordered_map<K, V>& umap) {
    std::stringstream ss;
    ss << "{";
    for (const auto& pair : umap) {
        ss << "\"" << pair.first << "\":\"" << pair.second << "\",";
    }

    std::string result = ss.str();
    if (result.length() > 1) {
        result.pop_back(); // Remove the trailing comma
    }
    result += "}";
    return result;
}

# ```
# 

```./vm/helpers/exec_step.cpp
#include <iomanip>
#include <iostream>
#include "../helpers/exec_step.hpp"
#include "../core/Process.hpp"
#include "../core/opmap.hpp"
#include "../core/Bytecode.hpp"
#include "../exec/exec.hpp"
#include "../obj/BuiltinFn.hpp"
#include "../obj/FunctionObject.hpp"
#include "../obj/ClassObject.hpp"

void exec_step(Process& p) {
    Bytecode& instr = p.module.at(p.pc);
    bool ok = false;
    size_t before = p.pc;
    // std::cout << "Executing process id: '" << std::setw(5) << std::setfill('0') << p.pc << "'; bytecode: '" + instr.toString() + "'" << std::endl;
    switch (instr.opcode) {
        case OP_PUSH:       ok = exec::PUSH  (p);    break;
        case OP_POP:        ok = exec::POP   (p);    break;
        case OP_DUP:        ok = exec::DUP   (p);    break;
        case OP_DECL:       ok = exec::DECL  (p);    break;
        case OP_SWAP:       ok = exec::SWAP  (p);    break;
        case OP_SET:        ok = exec::SET   (p);    break;
        case OP_GET:        ok = exec::GET   (p);    break;
        case OP_DEL:        ok = exec::DEL   (p);    break;
        case OP_WRITE:      ok = exec::WRITE (p);    break;
        case OP_FLUSH:      ok = exec::FLUSH (p);    break;
        case OP_DUMP:       ok = exec::DUMP  (p);    break;
        case OP_ADD:        ok = exec::ADD   (p);    break;
        case OP_SUB:        ok = exec::SUB   (p);    break;
        case OP_MUL:        ok = exec::MUL   (p);    break;
        case OP_DIV:        ok = exec::DIV   (p);    break;
        case OP_MOD:        ok = exec::MOD   (p);    break;
        case OP_EQ:         ok = exec::EQ    (p);    break;
        case OP_GT:         ok = exec::GT    (p);    break;
        case OP_LT:         ok = exec::LT    (p);    break;
        case OP_AND:        ok = exec::AND   (p);    break;
        case OP_OR:         ok = exec::OR    (p);    break;
        case OP_NOT:        ok = exec::NOT   (p);    break;
        case OP_JMP:        ok = exec::JMP   (p);    break;
        case OP_JNZ:        ok = exec::JNZ   (p);    break;
        case OP_JZ:         ok = exec::JZ    (p);    break;
        case OP_EXIT:       ok = exec::EXIT  (p);    break;
        case OP_RET:        ok = exec::RET   (p);    break;
        case OP_CALL: {
            // If the CALL bytecode has an operand, it's the old label-jump convention:
            if (!instr.operand.empty()) {
                ok = exec::CALL(p);
            }

            else {
                // Dynamic call: the top of the stack must be a callable object
                auto candidate = p.stack.back();

                // Try BuiltinFn
                if (auto bf = std::dynamic_pointer_cast<BuiltinFn>(candidate)) {
                    p.stack.pop();
                    ok = bf->invoke(p);
                }
                // Try user-defined FunctionObject
                else if (auto fo = std::dynamic_pointer_cast<FunctionObject>(candidate)) {
                    p.stack.pop();
                    ok = fo->invoke(p);
                }
                // Try ClassObject (constructor)
                else if (auto co = std::dynamic_pointer_cast<ClassObject>(candidate)) {
                    p.stack.pop();
                    ok = co->invoke(p);
                }
                else {
                    throw std::runtime_error(
                        "OP_CALL: top of stack is not callable (got "
                        + candidate->__name__() + ")"
                    );
                }
            }
            break;
        }
        case OP_RAND:       ok = exec::RAND  (p);    break;
        case OP_TIME:       ok = exec::TIME  (p);    break;
        case NOP:                                    break;
        case OP_LABEL:      ok = true;               break;
        case OP_TYPE:       ok = exec::TYPE  (p);    break;
        case OP_CAST:       ok = exec::CAST  (p);    break;
        case OP_IN:                                  break;
        case OP_SLEEP:                               break;
        case OP_FREAD:                               break;
        case OP_FWRITE:                              break;
        case OP_LIST_GET:   ok = exec::LIST_GET(p);  break;
        case OP_LIST_SET:   ok = exec::LIST_SET(p);  break;
        case OP_LIST_LEN:   ok = exec::LIST_LEN(p);  break;
        case OP_LIST_NEW:   ok = exec::LIST_NEW(p);  break;
        case OP_LIST_INS:   ok = exec::LIST_INS(p);  break;
        case OP_ACCESS:     ok = exec::ACCESS  (p);  break;
        case OP_END:        ok = true;               break;
        default:
            throw std::runtime_error("Opcode not implemented");
    }
    if (!ok) {
        p.broken = true;
        p.err("Exited with an error from " + get_string_from_opcode(instr.opcode));
    }

    if (p.pc == before && !p.completed && !p.broken) {
        p.pc++;
    }
}

# ```
# 

```./vm/helpers/trim.hpp
#pragma once
#include <string>

std::string trim(const std::string &s);

# ```
# 

```./vm/helpers/str_decode.cpp
#include "str_decode.hpp"

void str_decode(std::string& str) {
    if (!(str.starts_with('"') && str.ends_with('"')))
        throw "Invalid input string";

    str = str.substr(1, str.length() - 2);
    std::string result;
    result.reserve(str.size()); // Reserve enough memory to avoid reallocations

    for (size_t i = 0; i < str.size(); ++i) {
        if (str[i] == '\\' && i + 1 < str.size()) {
            char next = str[i + 1];
            switch (next) {
                case 'n': result += '\n'; break;
                case 'r': result += '\r'; break;
                case 't': result += '\t'; break;
                case '\\': result += '\\'; break;
                case '"': result += '"'; break;
                case '\'': result += '\''; break;
                case '0': result += '\0'; break;
                default:
                    // Unknown escape: copy as-is
                    result += '\\';
                    result += next;
                    break;
            }
            ++i; // Skip the next character because it's part of escape
        } else {
            result += str[i];
        }
    }

    str = std::move(result); // Replace original string with decoded one
}

# ```
# 

```./vm/helpers/is_valid_identifier.cpp
#include <regex>
#include "is_valid_identifier.hpp"

bool is_valid_identifier(const std::string& s) {
    static const std::regex expr("^[a-zA-Z_][a-zA-Z_0-9]*$");
    return std::regex_match(s, expr);
}

# ```
# 

```./vm/helpers/parse_raw_bytecode.hpp
#pragma once
#include <vector>
#include <string>
#include "../core/Bytecode.hpp"

std::vector<Bytecode> parse_raw_bytecode(const std::string &input);

# ```
# 

```./vm/helpers/exec_step.hpp
#pragma once
#include <iostream>
#include "../core/Process.hpp"

void exec_step(Process&);

# ```
# 

```./vm/helpers/trim.cpp
#include "trim.hpp"
#include <string>

std::string trim(const std::string &s) {
    auto a = std::find_if_not(s.begin(), s.end(), [](char c){ return std::isspace(c); });
    auto b = std::find_if_not(s.rbegin(), s.rend(), [](char c){ return std::isspace(c); }).base();
    return (b <= a ? std::string() : std::string(a, b));
}

# ```
# 

```./vm/helpers/str_decode.hpp
#pragma once
#include <string>

/**
 * Decodes a given string modifying the original string
 * e.g. str_decode("\"hello\n world!\"") becomes;
 * "hello
 *   world!"
 */
void str_decode(std::string& str);

# ```
# 

```./vm/helpers/is_valid_identifier.hpp
#pragma once
#include <string>

bool is_valid_identifier(const std::string&);

# ```
# 

```./vm/helpers/parse_raw_bytecode.cpp
#include <iostream>
#include "parse_raw_bytecode.hpp"
#include <vector>
#include <string>
#include <sstream>
#include "../core/Bytecode.hpp"
#include "../core/opmap.hpp"
#include "trim.hpp"
#include "split.hpp"

std::vector<Bytecode> parse_raw_bytecode(const std::string &input) {
    std::vector<Bytecode> code;
    std::istringstream lines(input);
    std::string line;

    while (std::getline(lines, line)) {
        // remove comments
        line = trim(line);
        if (line.empty())
            continue;

        // function label
        if (line[0] == '.') {
            code.push_back({ OP_LABEL, { line } });
            continue;
        }

        // (OPCODE,arg1,arg2â€¦)
        if (line.front() == '(' && line.back() == ')') {
            auto inner = line.substr(1, line.size()-2);
            auto parts = split(inner, ',');
            auto it = opmap.find(parts[0]);
            if (it == opmap.end())
                throw std::runtime_error("Unknown opcode: " + parts[0]);
            Opcode opc = it->second;
            std::vector<std::string> args(parts.begin()+1, parts.end());
            code.push_back({ opc, args });
            continue;
        }

        throw std::runtime_error("Invalid line in bytecode: " + line);
    }

    return code;
}

# ```
# 

```./vm/helpers/parse_literal.cpp
#include "parse_literal.hpp"
#include <cctype> // for std::isdigit
#include <stdexcept>

std::shared_ptr<Object> parse_literal(const std::string& tok) {
    // --- Booleans ---
    if (tok == "true")  return std::make_shared<Boolean>(true);
    if (tok == "false") return std::make_shared<Boolean>(false);

    // --- Indefinites ---
    if (tok == "nil") return Nil::instance();
    if (tok == "nix") return Nix::instance();
    if (tok == "nan") return NaN::instance();


    // --- Regular Expression Literals ---
    if (tok.size() >= 4 && tok[0] == 'r' && tok[1] == '/' && tok.find('/', 2) != std::string::npos) {
        auto lastSlash = tok.rfind('/');
        std::string pattern = tok.substr(2, lastSlash - 2);
        std::string flagsStr = tok.substr(lastSlash + 1);
        std::set<char> flags(flagsStr.begin(), flagsStr.end());
        return std::make_shared<RegEx>(pattern, flags);
    }

    // --- String Literals ---
    if (tok.size() >= 2 &&
        ((tok.front() == '"' && tok.back() == '"') ||
         (tok.front() == '\'' && tok.back() == '\''))) {
        std::string _tok = tok;
        str_decode(_tok);
        return std::make_shared<String>(_tok);
    }

    // --- Numeric Literals ---
    {
        size_t start = 0;
        if (tok[0] == '+' || tok[0] == '-') start = 1;

        bool hasDot = false;
        bool hasExp = false;
        for (size_t i = start; i < tok.size(); ++i) {
            if (tok[i] == '.') {
                if (hasDot) {
                    throw std::runtime_error("Invalid number: multiple dots in " + tok);
                }
                hasDot = true;
            }
            else if (tok[i] == 'e' || tok[i] == 'E') {
                if (hasExp) {
                    throw std::runtime_error("Invalid number: multiple exponents in " + tok);
                }
                hasExp = true;
            }
            else if (!std::isdigit(static_cast<unsigned char>(tok[i]))) {
                throw std::runtime_error("Invalid character '" + std::string(1, tok[i]) + "' in numeric literal: " + tok);
            }
        }

        try {
            if (hasDot) {
                double v = std::stod(tok);
                return std::make_shared<Float>(v);
            }
            int64_t v = std::stoll(tok);
            return std::make_shared<Integer>(v);
        }
        catch (const std::exception& e) {
            throw std::runtime_error("Failed to parse numeric literal: " + tok);
        }
    }

    throw std::runtime_error("Invalid literal: " + tok);
}

# ```
# 

```./vm/helpers/str_encode.hpp
#pragma once
#include <string>

/**
 * Encodes a given string modifying the original string
 * e.g. str_decode("\"hello\n world!\"") becomes;
 * \\"hello\\nworld!\\"
 */
void str_encode(std::string& str);

# ```
# 

```./vm/helpers/get_nanotime.cpp
#include <chrono>
#include "get_nanotime.hpp"

int64_t get_nanotime() {
    using namespace std::chrono;
    return duration_cast<nanoseconds>(
        high_resolution_clock::now().time_since_epoch()
    ).count();
}

# ```
# 

```./vm/helpers/unordered_map_to_string.hpp
#pragma once
#include <sstream>
#include <unordered_map>
#include <string>

template <typename K, typename V>
std::string unordered_map_to_string(const std::unordered_map<K, V>& umap);

# ```
# 

```./vm/helpers/split.hpp
#pragma once
#include <string>
#include <vector>

std::vector<std::string> split(const std::string &s, char d);

# ```
# 
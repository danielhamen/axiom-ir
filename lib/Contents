```./emitter/Emitter.cpp
#include <string>
#include <random>
#include <any>
#include <iostream>
#include "Emitter.hpp"
#include <stdexcept>
#include <vector>
#include <memory>

Emitter::Emitter(std::vector<std::shared_ptr<ASTNode>>& program)
    : program(program) {}

std::vector<Bytecode> Emitter::emit() {
    std::vector<Bytecode> main; // .main entry code
    std::vector<Bytecode> structural; // passive code like definitions of functions, classes, etc
    main.push_back({OP_LABEL, {"main"}});

    for (const auto& node : program) {
        auto code = emit_node(node);
        for (auto b : code) {
            // std::cout << b.toString() << std::endl;
            if (node->type == ASTNodeType::FUNCTION_STMT) {
                structural.push_back(b);
            } else {
                main.push_back(b);
            }
        }
    }

    main.push_back({OP_EXIT, {}});

    std::vector<Bytecode> result;
    result.insert(result.begin(), structural.begin(), structural.end());
    result.insert(result.end(), main.begin(), main.end());
    return result;
}

std::vector<Bytecode> Emitter::emit_node(const std::shared_ptr<ASTNode>& node) {
    switch (node->type) {
        case ASTNodeType::DECLARATION:
            return emit_declaration(std::static_pointer_cast<Declaration>(node));
        case ASTNodeType::LITERAL:
            return emit_literal(std::static_pointer_cast<Literal>(node));
        case ASTNodeType::BINARY_OP:
            return emit_binary_op(std::static_pointer_cast<BinaryOp>(node));
        case ASTNodeType::VARIABLE:
            return emit_variable(std::static_pointer_cast<Variable>(node));
        case ASTNodeType::IF_STMT:
            return emit_if_stmt(std::static_pointer_cast<IfStmt>(node));
        case ASTNodeType::META_STMT:
            return emit_meta_stmt(std::static_pointer_cast<MetaStmt>(node));
        case ASTNodeType::FUNCTION_STMT:
            return emit_function_stmt(std::static_pointer_cast<FunctionStmt>(node));
        case ASTNodeType::RETURN_STMT:
            return emit_return(std::static_pointer_cast<ReturnStmt>(node));
        case ASTNodeType::CALL_EXPR:
            return emit_call_expr(std::static_pointer_cast<CallExpr>(node));
        case ASTNodeType::EXPRESSION_STMT:
            return emit_expression_stmt(std::static_pointer_cast<ExpressionStmt>(node));
        default:
            std::cout << ast_to_string(node) << std::endl;
            throw std::runtime_error("<unknown AST node type>");
    }
}

std::string random_identifier(size_t length = 12) {
    static const std::string chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789";
    static std::mt19937 rng(std::random_device{}());
    static std::uniform_int_distribution<> dist(0, chars.size() - 1);

    std::string result = "_";
    result.reserve(length);
    for (size_t i = 0; i < length - 1; ++i) {
        result += chars[dist(rng)];
    }
    return result;
}

std::vector<Bytecode> Emitter::emit_function_stmt(const std::shared_ptr<FunctionStmt>& funcStmt) {
    std::vector<Bytecode> code;

    // std::string ref_name = random_identifier();

    auto func_name = std::dynamic_pointer_cast<Variable>(funcStmt->name);

    // --- Function entry label ---
    code.push_back({ OP_LABEL, { func_name->name } });
    // code.push_back({ OP_JMP, { ref_name } });

    // // --- Function body label ---
    // code.push_back({ OP_LABEL, { ref_name } });

    // Emit function body
    for (auto stmt : funcStmt->body) {
        auto stmt_code = emit_node(stmt);
        code.insert(code.end(), stmt_code.begin(), stmt_code.end());
    }

    // Function return
    code.push_back({ OP_RET, {} });
    code.push_back({ OP_END, {} });

    return code;
}

std::vector<Bytecode> Emitter::emit_return(const std::shared_ptr<ReturnStmt>& retStmt) {
    std::vector<Bytecode> code;

    if (retStmt->value.has_value()) {
        auto value = retStmt->value.value();
        auto value_code = emit_node(value);
        code.insert(code.end(), value_code.begin(), value_code.end());
    }

    return code;
}

std::vector<Bytecode> Emitter::emit_expression_stmt(const std::shared_ptr<ExpressionStmt>& exprStmt) {
    std::vector<Bytecode> code;
    std::cout << "Cannot directly emit expression statement" << std::endl;

    return code;
}

std::vector<Bytecode> Emitter::emit_call_expr(const std::shared_ptr<CallExpr>& callExpr) {
    std::vector<Bytecode> code;
    std::cout << "Emitting call expression" << std::endl;
    auto callee = std::dynamic_pointer_cast<Variable>(callExpr->callee);
    code.push_back({ OP_CALL, { callee->name } });

    return code;
}

std::vector<Bytecode> Emitter::emit_meta_stmt(const std::shared_ptr<MetaStmt>& metaStmt) {
    std::vector<Bytecode> code;

    // Correctly cast ASTNode -> Variable
    auto ns = std::dynamic_pointer_cast<Variable>(metaStmt->ns);
    if (!ns) {
        throw std::runtime_error("MetaStmt ns is not a Variable.");
    }

    auto callee_var = std::dynamic_pointer_cast<Variable>(metaStmt->call);
    if (!callee_var) {
        throw std::runtime_error("MetaStmt call is not a Variable.");
    }

    auto callee = callee_var->name;
    auto args = metaStmt->arg;

    // Functions
    if (args.has_value()) {
        if (callee == "Emit") {
            if (!args.has_value() || args->size() != 1) {
                throw std::runtime_error("Meta.Emit(...) expects exactly one argument. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            auto first_arg = args->at(0);
            auto lit = std::dynamic_pointer_cast<Literal>(first_arg);
            if (!lit) {
                throw std::runtime_error("Meta.Emit(...) expects a literal string argument.");
            }

            if (!lit->is_str()) {
                throw std::runtime_error("Meta.Emit(...) expects a single string argument.");
            }

            std::string raw_code = lit->value;
            str_decode(raw_code);
            std::vector<Bytecode> code = parse_raw_bytecode(raw_code);
            return code;
        }
        if (callee == "Time") {
            if (!args.has_value() || args->size() != 0) {
                throw std::runtime_error("Meta.Time() expects exactly zero arguments. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            std::vector<Bytecode> code = parse_raw_bytecode("(TIME)");
            return code;
        }
        if (callee == "Random") {
            if (!args.has_value() || args->size() != 0) {
                throw std::runtime_error("Meta.Random() expects exactly zero arguments. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            std::vector<Bytecode> code = parse_raw_bytecode("(RAND)");
            return code;
        }
        if (callee == "Pop") {
            // ensure variable passed as single parameter
            if (!args.has_value() || args->size() != 1) {
                throw std::runtime_error("Meta.Pop(...) expects exactly one argument. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            auto abstract_var = args.value().front();
            if (abstract_var->type != ASTNodeType::VARIABLE) {
                throw std::runtime_error("Meta.Pop(...) expects a variable argument. Given: " + (args ? std::to_string(static_cast<int>(abstract_var->type)) : "none"));
            }

            auto var = std::dynamic_pointer_cast<Variable>(abstract_var);
            std::vector<Bytecode> code = parse_raw_bytecode("(SET, $" + var->name + ")");
            return code;
        }
        if (callee == "Push") {
            // ensure variable passed as single parameter
            if (!args.has_value() || args->size() != 1) {
                throw std::runtime_error("Meta.Push(...) expects exactly one argument. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            auto abstract_var = args.value().front();
            if (abstract_var->type != ASTNodeType::VARIABLE) {
                throw std::runtime_error("Meta.Push(...) expects a variable argument. Given: " + (args ? std::to_string(static_cast<int>(abstract_var->type)) : "none"));
            }

            auto var = std::dynamic_pointer_cast<Variable>(abstract_var);
            std::vector<Bytecode> code = parse_raw_bytecode("(GET, $" + var->name + ")");
            return code;
        }
        if (callee == "Write") {
            if (!args.has_value() || args->size() != 0) {
                throw std::runtime_error("Meta.Write() expects exactly zero arguments. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            std::vector<Bytecode> code = parse_raw_bytecode("(WRITE)");
            return code;
        }
        if (callee == "WriteLine") {
            if (!args.has_value() || args->size() != 0) {
                throw std::runtime_error("Meta.WriteLine() expects exactly zero arguments. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            std::vector<Bytecode> code = parse_raw_bytecode("(PUSH, \"\\n\")\n(WRITE)");
            return code;
        }
        if (callee == "Flush") {
            if (!args.has_value() || args->size() != 0) {
                throw std::runtime_error("Meta.Flush() expects exactly zero arguments. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            std::vector<Bytecode> code = parse_raw_bytecode("(FLUSH)");
            return code;
        }
        if (callee == "Dump") {
            if (!args.has_value() || args->size() != 0) {
                throw std::runtime_error("Meta.Dump() expects exactly zero arguments. Given: " + (args ? std::to_string(args->size()) : "none"));
            }

            std::vector<Bytecode> code = parse_raw_bytecode("(DUMP)");
            return code;
        }
    }
    // Properties
    else {
        // Handle property access...
    }

    throw std::runtime_error("Unexpected Meta call: '" + callee + "'");
}

std::vector<Bytecode> Emitter::emit_if_stmt(const std::shared_ptr<IfStmt>& var) {
    std::vector<Bytecode> code;

    return code;
}

std::vector<Bytecode> Emitter::emit_variable(const std::shared_ptr<Variable>& var) {
    std::vector<Bytecode> code;
    code.push_back({ OP_GET, { "$" + var->name } });

    return code;
}

std::vector<Bytecode> Emitter::emit_binary_op(const std::shared_ptr<BinaryOp>& binop) {
    std::vector<Bytecode> code;
    Opcode o;
    if (binop->op == "+") {
        o = Opcode::OP_ADD;
    } else if (binop->op == "-") {
        o = Opcode::OP_SUB;
    } else if (binop->op == "*") {
        o = Opcode::OP_MUL;
    } else if (binop->op == "/") {
        o = Opcode::OP_DIV;
    } else if (binop->op == "%") {
        o = Opcode::OP_MOD;
    } else if (binop->op == "&&") {
        o = Opcode::OP_AND;
    } else if (binop->op == "||") {
        o = Opcode::OP_OR;
    }

    // left side
    auto left_code = emit_node(binop->left);
    code.insert(code.end(), left_code.begin(), left_code.end());

    // right side
    auto right_code = emit_node(binop->right);
    code.insert(code.end(), right_code.begin(), right_code.end());

    code.push_back(Bytecode{ o, {} });

    return code;
}

std::vector<Bytecode> Emitter::emit_literal(const std::shared_ptr<Literal>& literal) {
    std::vector<Bytecode> code;

    auto lit = static_cast<Literal*>(literal.get());
    std::string value = lit->value;
    if (lit->is_str()) {
        str_encode(value);
    }

    code.push_back({
        OP_PUSH,
        {value}
    });

    return code;
}

std::vector<Bytecode> Emitter::emit_declaration(const std::shared_ptr<Declaration>& decl) {
    std::vector<Bytecode> code;

    auto pattern = std::dynamic_pointer_cast<VariablePattern>(decl->pattern);
    if (!pattern) {
        throw std::runtime_error("Only simple variable declarations are supported for now.");
    }

    const std::string& name = pattern->name;
    std::string type = decl->type_annotation.value_or("Any");

    // Step 1: Declare the variable (before any value is assigned!)
    code.push_back(Bytecode{ OP_DECL, { "$" + name } });

    // Step 2: Annotate its type
    code.push_back(Bytecode{ OP_TYPE, { "$" + name, type } });

    // Step 3: If initializer exists, assign value into it
    if (decl->initializer.has_value()) {
        // 3a: emit code to compute the initializer
        auto init_code = emit_node(decl->initializer.value());
        code.insert(code.end(), init_code.begin(), init_code.end());

        // 3b: after computing, set it into variable
        code.push_back(Bytecode{ OP_SET, { "$" + name } });
    }

    return code;
}

# ```
# 

```./emitter/Emitter.hpp

#pragma once

#include <string>
#include <vector>
#include <memory>
#include "../vm/helpers/parse_raw_bytecode.hpp"
#include "../vm/helpers/str_decode.hpp"
#include "../vm/helpers/str_encode.hpp"
#include "../frontend/AST.hpp"
#include "../vm/core/Bytecode.hpp"

class Emitter {
public:
    std::vector<std::shared_ptr<ASTNode>>& program;
    Emitter(std::vector<std::shared_ptr<ASTNode>>& program);

    // Main entrypoint: emit bytecode for a full AST
    std::vector<Bytecode> emit();

private:
    std::vector<Bytecode> bytecode;
    std::vector<Bytecode> emit_node(const std::shared_ptr<ASTNode>& node);
    std::vector<Bytecode> emit_declaration(const std::shared_ptr<Declaration>& decl);
    std::vector<Bytecode> emit_expression_stmt(const std::shared_ptr<ExpressionStmt>& exprStmt);
    std::vector<Bytecode> emit_function_stmt(const std::shared_ptr<FunctionStmt>& funcStmt);
    std::vector<Bytecode> emit_assignment(const std::shared_ptr<Assignment>& assign);
    std::vector<Bytecode> emit_binary_op(const std::shared_ptr<BinaryOp>& binop);
    std::vector<Bytecode> emit_unary_op(const std::shared_ptr<UnaryOp>& unop);
    std::vector<Bytecode> emit_literal(const std::shared_ptr<Literal>& literal);
    std::vector<Bytecode> emit_variable(const std::shared_ptr<Variable>& variable);
    std::vector<Bytecode> emit_meta_stmt(const std::shared_ptr<MetaStmt>& metaStmt);
    std::vector<Bytecode> emit_call_expr(const std::shared_ptr<CallExpr>& callExpr);
    std::vector<Bytecode> emit_if_stmt(const std::shared_ptr<IfStmt>& ifStmt);
    std::vector<Bytecode> emit_return(const std::shared_ptr<ReturnStmt>& ret);
};

# ```
# 

```./frontend/TokenType.hpp
#pragma once

enum TokenType {
    // --- Literals
    TOK_INTEGER,     // 123
    TOK_DECIMAL,     // 3.14
    TOK_STRING,      // "hello"

    // --- Identifiers / Keywords
    TOK_IDENTIFIER,  // x, foo, myVar
    TOK_KEYWORD,     // let, if, else, return,

    // --- Operators
    TOK_PLUS,        // +
    TOK_MINUS,       // -
    TOK_ASTERISK,    // *
    TOK_SLASH,       // /
    TOK_PERCENT,     // %

    TOK_EQUAL,       // ==
    TOK_NOT_EQUAL,   // !=
    TOK_LESS,        // <
    TOK_LESS_EQUAL,  // <=
    TOK_GREATER,     // >
    TOK_GREATER_EQUAL, // >=

    TOK_ASSIGN,      // =

    TOK_AND,         // &&
    TOK_OR,          // ||
    TOK_NOT,         // !

    // --- Symbols
    TOK_LPAREN,      // (
    TOK_RPAREN,      // )
    TOK_LBRACKET,    // [
    TOK_RBRACKET,    // ]
    TOK_LBRACE,      // {
    TOK_RBRACE,      // }
    TOK_COMMA,       // ,
    TOK_DOT,         // .
    TOK_COLON,       // :
    TOK_SEMICOLON,   // ;

    // --- Special
    TOK_EOF,         // End of file/input
    TOK_UNKNOWN      // Invalid/unknown character
};

# ```
# 

```./frontend/match_keyword.cpp
#include "match_keyword.hpp"
std::optional<Keyword> match_keyword(const std::string& word) {
    if (word == "let")      return KW_LET;
    if (word == "if")       return KW_IF;
    if (word == "elif")     return KW_ELIF;
    if (word == "else")     return KW_ELSE;
    if (word == "while")    return KW_WHILE;
    if (word == "Meta")     return KW_META;
    if (word == "guard")    return KW_GUARD;
    if (word == "for")      return KW_FOR;
    if (word == "in")       return KW_IN;
    if (word == "break")    return KW_BREAK;
    if (word == "continue") return KW_CONTINUE;
    if (word == "return")   return KW_RETURN;
    if (word == "func")     return KW_FUNC;
    if (word == "fn")       return KW_FN;
    if (word == "lambda")   return KW_LAMBDA;
    if (word == "struct")   return KW_STRUCT;
    if (word == "import")   return KW_IMPORT;
    if (word == "export")   return KW_EXPORT;
    if (word == "as")       return KW_AS;
    if (word == "match")    return KW_MATCH;
    if (word == "case")     return KW_CASE;
    if (word == "default")  return KW_DEFAULT;
    if (word == "true")     return KW_TRUE;
    if (word == "false")    return KW_FALSE;
    if (word == "null")     return KW_NULL;
    return std::nullopt;
}

# ```
# 

```./frontend/Keyword.hpp
#pragma once

enum Keyword {
    KW_LET,             // variable declaration
    KW_IF,              // if block
    KW_ELIF,            // else-if block
    KW_ELSE,            // else block
    KW_GUARD,           // guard block
    KW_WHILE,           // while loop
    KW_FOR,             // for loop
    KW_IN,              // for ... in ...
    KW_BREAK,           // break out of loop
    KW_CONTINUE,        // continue loop
    KW_RETURN,          // return from function
    KW_META,            // Meta keyword
    KW_FN,              // inline-function declaration
    KW_LAMBDA,          // lambda-function declaration
    KW_FUNC,            // function declaration
    KW_STRUCT,          // struct declaration
    KW_IMPORT,          // import modules
    KW_EXPORT,          // export functions/types
    KW_AS,              // rename imports
    KW_MATCH,           // pattern matching (like switch)
    KW_CASE,            // case branch inside match
    KW_DEFAULT,         // default branch inside match
    KW_TRUE,            // literal true
    KW_FALSE,           // literal false
    KW_NULL,            // literal null
    KW_TRY,             // try block
    KW_CATCH,           // catch block
    KW_THROW,           // throw an error
    KW_DEFER,           // run after scope exit (golang-style)
    KW_TYPE,            // user-defined type (aliasing)
};

# ```
# 

```./frontend/Desugarer.cpp
#include "Desugarer.hpp"
#include "AST.hpp"

Desugarer::Desugarer(std::vector<std::shared_ptr<ASTNode>>& ast) : ast(ast) {};

std::vector<std::shared_ptr<ASTNode>> Desugarer::desugar() {
    std::vector<std::shared_ptr<ASTNode>> result;
    for (const auto& node : ast) {
        result.push_back(desugar_node(node));
    }
    return result;
}

std::shared_ptr<ASTNode> Desugarer::desugar_node(std::shared_ptr<ASTNode> node) {
    if (!node) return nullptr;

    switch (node->type) {
        // case ASTNodeType::DECLARATION:
        //     return desugar_declaration(std::static_pointer_cast<Declaration>(node));
        // case ASTNodeType::ASSIGNMENT:
        //     return desugar_assignment(std::static_pointer_cast<Assignment>(node));
        // case ASTNodeType::EXPRESSION_STMT:
        //     return desugar_expression_stmt(std::static_pointer_cast<ExpressionStmt>(node));
        // case ASTNodeType::IF_STMT:
        //     return desugar_if_stmt(std::static_pointer_cast<IfStmt>(node));
        case ASTNodeType::GUARD_STMT:
            return desugar_guard_stmt(std::static_pointer_cast<GuardStmt>(node));
        // case ASTNodeType::WHILE_STMT:
        //     return desugar_while_stmt(std::static_pointer_cast<WhileStmt>(node));
        // case ASTNodeType::BLOCK_STMT:
        //     return desugar_block_stmt(std::static_pointer_cast<BlockStmt>(node));
        case ASTNodeType::FUNCTION_STMT:
            return desugar_func_decl(std::static_pointer_cast<FunctionStmt>(node));
        // case ASTNodeType::RETURN_STMT:
        //     return desugar_return_stmt(std::static_pointer_cast<ReturnStmt>(node));
        // case ASTNodeType::STRUCT_DECL:
        //     return desugar_struct_decl(std::static_pointer_cast<StructDecl>(node));
        // case ASTNodeType::IMPORT_DECL:
        //     return desugar_import_decl(std::static_pointer_cast<ImportDecl>(node));
        // case ASTNodeType::CALL_EXPR:
        //     return desugar_call_expr(std::static_pointer_cast<CallExpr>(node));
        default:
            // For things like literals, variables, binary ops, just return as is
            return node;
    }
}

// --- Individual desugar methods ---

std::shared_ptr<ASTNode> Desugarer::desugar_declaration(std::shared_ptr<Declaration> decl) {
    // TODO: handle destructuring, multiple vars, chained assignment, etc.
    return decl;
}

std::shared_ptr<ASTNode> Desugarer::desugar_assignment(std::shared_ptr<Assignment> assign) {
    // TODO: handle chained assignment: x = y = z = 5;
    return assign;
}

std::shared_ptr<ASTNode> Desugarer::desugar_expression_stmt(std::shared_ptr<ExpressionStmt> expr_stmt) {
    expr_stmt->expression = desugar_node(expr_stmt->expression);
    return expr_stmt;
}

std::shared_ptr<ASTNode> Desugarer::desugar_if_stmt(std::shared_ptr<IfStmt> if_stmt) {
    // if_stmt->condition = desugar_node(if_stmt->condition);
    // if_stmt->thenBranch = desugar_node(if_stmt->thenBranch);
    // if (if_stmt->elseBranch.has_value()) {
    //     if_stmt->elseBranch = desugar_node(if_stmt->elseBranch.value());
    // }
    return if_stmt;
}

std::shared_ptr<ASTNode> Desugarer::desugar_guard_stmt(std::shared_ptr<GuardStmt> guard_stmt) {
    // Build a NOT(cond) expression
    auto not_condition = std::make_shared<UnaryOp>("!", desugar_node(guard_stmt->condition));

    auto else_branch = desugar_node(guard_stmt->elseBranch);

    return std::make_shared<IfStmt>(
        not_condition,
        else_branch
    );
}

std::shared_ptr<ASTNode> Desugarer::desugar_while_stmt(std::shared_ptr<WhileStmt> while_stmt) {
    // while_stmt->condition = desugar_node(while_stmt->condition);
    // while_stmt->body = desugar_node(while_stmt->body);
    return while_stmt;
}

std::shared_ptr<ASTNode> Desugarer::desugar_block_stmt(std::shared_ptr<BlockStmt> block_stmt) {
    // std::vector<std::shared_ptr<ASTNode>> new_statements;
    // for (auto& stmt : block_stmt->statements) {
    //     new_statements.push_back(desugar_node(stmt));
    // }
    // block_stmt->statements = std::move(new_statements);
    return block_stmt;
}

std::shared_ptr<ASTNode> Desugarer::desugar_func_decl(std::shared_ptr<FunctionStmt> func_decl) {
    for (int i = 0; i < func_decl->body.size(); i++) {
        func_decl->body.at(i) = desugar_node(func_decl->body.at(i));
    }

    return func_decl;
}

std::shared_ptr<ASTNode> Desugarer::desugar_return_stmt(std::shared_ptr<ReturnStmt> return_stmt) {
    // if (return_stmt->value.has_value()) {
    //     return_stmt->value = desugar_node(return_stmt->value.value());
    // }
    return return_stmt;
}

std::shared_ptr<ASTNode> Desugarer::desugar_struct_decl(std::shared_ptr<StructDecl> struct_decl) {
    // Usually nothing to desugar here yet
    return struct_decl;
}

std::shared_ptr<ASTNode> Desugarer::desugar_import_decl(std::shared_ptr<ImportDecl> import_decl) {
    // Nothing to desugar
    return import_decl;
}

std::shared_ptr<ASTNode> Desugarer::desugar_call_expr(std::shared_ptr<CallExpr> call_expr) {
    // call_expr->callee = desugar_node(call_expr->callee);
    // for (auto& arg : call_expr->arguments) {
    //     arg = desugar_node(arg);
    // }
    return call_expr;
}

// --- Utility ---

std::shared_ptr<BlockStmt> Desugarer::flatten(const std::vector<std::shared_ptr<ASTNode>>& stmts) {
    return std::make_shared<BlockStmt>(stmts);
}

# ```
# 

```./frontend/Parser.hpp
#pragma once
#include <vector>
#include <optional>
#include <memory>
#include "Token.hpp"
#include "TokenType.hpp"
#include "Keyword.hpp"
#include "AST.hpp" // (you'll define the ASTNode, Assignment, BinaryOp, etc.)

class Parser {
public:
    explicit Parser(const std::vector<Token>& tokens);

    std::vector<std::shared_ptr<ASTNode>> parse();

private:
    const std::vector<Token>& tokens;
    size_t current = 0;

    // Core helpers
    bool at_end() const;
    const Token& advance();
    const Token& peek() const;
    const Token& previous() const;
    bool match(std::initializer_list<TokenType> types);
    bool check(TokenType type) const;
    std::vector<Token> collect_until_keyword_or(TokenType stop, const std::string& keyword);
    std::shared_ptr<ASTNode> parse_head(const std::vector<Token>& head_tokens);
    std::shared_ptr<BlockStmt> parse_block();
    std::shared_ptr<ASTNode> parse_call(std::shared_ptr<ASTNode> callee);

    void synchronize(); // error recovery (optional later)

    // Parsing functions
    std::shared_ptr<ASTNode> parse_statement();
    std::shared_ptr<ASTNode> parse_expression();
    std::shared_ptr<ASTNode> parse_assignment();
    std::shared_ptr<ASTNode> parse_term();
    std::shared_ptr<ASTNode> parse_factor();
    std::shared_ptr<ASTNode> parse_primary();
    std::shared_ptr<ASTNode> parse_or();
    std::shared_ptr<ASTNode> parse_and();
    std::shared_ptr<ASTNode> parse_equality();
    std::shared_ptr<ASTNode> parse_comparison();
    std::shared_ptr<ASTNode> parse_unary();

    // Specific statement parsers
    std::shared_ptr<ASTNode> parse_let();
    std::shared_ptr<ASTNode> parse_for();
    std::shared_ptr<ASTNode> parse_return();
    std::shared_ptr<ASTNode> parse_meta();
    std::shared_ptr<ASTNode> parse_guard();
    std::shared_ptr<ASTNode> parse_function();

    // Utilities
    std::shared_ptr<BlockStmt> parse_block_already_open();
    std::shared_ptr<BlockStmt> parse_block_no_open();
    Token consume(TokenType type, const std::string& error_message);
};

# ```
# 

```./frontend/AST.cpp
#include "AST.hpp"
#include <string>

// --- ASTNode Destructor ---
ASTNode::~ASTNode() {}

// --- Literal Constructor ---
Literal::Literal(const std::string& val) : value(val) {
    type = ASTNodeType::LITERAL;
}
bool Literal::is_str() {
    return value.starts_with('"') && value.ends_with('"');
}
bool Literal::is_dec() {
    throw "not impl.";
}
bool Literal::is_int() {
    throw "not impl.";
}

// --- Variable Constructor ---
Variable::Variable(const std::string& n) : name(n) {
    type = ASTNodeType::VARIABLE;
}

// --- BinaryOp Constructor ---
BinaryOp::BinaryOp(const std::string& oper, std::shared_ptr<ASTNode> lhs, std::shared_ptr<ASTNode> rhs)
    : op(oper), left(std::move(lhs)), right(std::move(rhs)) {
    type = ASTNodeType::BINARY_OP;
}

// --- UnaryOp Constructor ---
UnaryOp::UnaryOp(const std::string& oper, std::shared_ptr<ASTNode> opd)
    : op(oper), operand(std::move(opd)) {
    type = ASTNodeType::UNARY_OP;
}

// --- Declaration Constructor ---
Declaration::Declaration(std::shared_ptr<ASTNode> pat,
                         std::optional<std::string> typeAnn,
                         std::optional<std::shared_ptr<ASTNode>> init)
    : pattern(std::move(pat)),
      type_annotation(std::move(typeAnn)),
      initializer(std::move(init)) {
    type = ASTNodeType::DECLARATION;
}

// --- Field Access Constructor ---
FieldAccess::FieldAccess(std::shared_ptr<ASTNode> object, const std::string& field)
    : object(object),
      field(field) {};

// --- VariablePattern Constructor ---
VariablePattern::VariablePattern(const std::string& n)
    : name(n) {
    type = ASTNodeType::VARIABLE_PATTERN;
}

// --- TuplePattern Constructor ---
TuplePattern::TuplePattern(std::vector<std::string> n)
    : names(std::move(n)) {
    type = ASTNodeType::TUPLE_PATTERN;
}

// --- DestructurePattern Constructor ---
DestructurePattern::DestructurePattern(std::vector<std::string> n, bool isArr)
    : names(std::move(n)), isArray(isArr) {
    type = ASTNodeType::DESTRUCTURE_PATTERN;
}

// --- Assignment Constructor ---
Assignment::Assignment(const std::string& n, std::shared_ptr<ASTNode> val)
    : name(n), value(std::move(val)) {
    type = ASTNodeType::ASSIGNMENT;
}

// --- ExpressionStmt Constructor ---
ExpressionStmt::ExpressionStmt(std::shared_ptr<ASTNode> expr) : expression(std::move(expr)) {
    type = ASTNodeType::EXPRESSION_STMT;
}

// --- MetaStmt Constructor ---
MetaStmt::MetaStmt(
    std::shared_ptr<ASTNode> ns,
    std::shared_ptr<ASTNode> call,
    std::optional<std::vector<std::shared_ptr<ASTNode>>> arg
)
    : ns(std::move(ns)), call(std::move(call)), arg(std::move(arg)) {
    type = ASTNodeType::META_STMT;
}

MetaStmt::MetaStmt(
    std::shared_ptr<ASTNode> ns,
    std::shared_ptr<ASTNode> call
)
    : ns(std::move(ns)), call(std::move(call)) {
    type = ASTNodeType::META_STMT;
}

// --- IfStmt Constructor ---
IfStmt::IfStmt(std::shared_ptr<ASTNode> cond, std::shared_ptr<ASTNode> thenB, std::vector<std::shared_ptr<ASTNode>> elifB, std::optional<std::shared_ptr<ASTNode>> elseB)
    : condition(std::move(cond)), thenBranch(std::move(thenB)), elifBranches(elifB), elseBranch(std::move(elseB)) {
    type = ASTNodeType::IF_STMT;
}

// --- GuardStmt Constructor ---
GuardStmt::GuardStmt(std::shared_ptr<ASTNode> cond, std::shared_ptr<ASTNode> elseB)
    : condition(std::move(cond)), elseBranch(std::move(elseB)) {
    type = ASTNodeType::GUARD_STMT;
}

// --- WhileStmt Constructor ---
WhileStmt::WhileStmt(std::shared_ptr<ASTNode> cond, std::shared_ptr<ASTNode> b)
    : condition(std::move(cond)), body(std::move(b)) {
    type = ASTNodeType::WHILE_STMT;
}

// --- ForInStmt Constructor ---
ForInStmt::ForInStmt(const std::string& n, std::shared_ptr<ASTNode> iter, std::shared_ptr<ASTNode> b)
    : varName(n), iterable(std::move(iter)), body(std::move(b)) {
    type = ASTNodeType::FOR_IN_STMT;
}

// --- BlockStmt Constructor ---
BlockStmt::BlockStmt(std::vector<std::shared_ptr<ASTNode>> stmts) : statements(std::move(stmts)) {
    type = ASTNodeType::BLOCK_STMT;
}

// --- FuncDecl Constructor ---
FunctionStmt::FunctionStmt(
    std::shared_ptr<ASTNode> name,
    std::vector<std::pair<std::shared_ptr<ASTNode>, std::shared_ptr<ASTNode>>> params,
    std::optional<std::shared_ptr<ASTNode>> returnType,
    std::vector<std::shared_ptr<ASTNode>> body
)
: name(name), params(params), returnType(returnType), body(body)
{
    type = ASTNodeType::FUNCTION_STMT;
}

// --- CallExpr Constructor ---
CallExpr::CallExpr(std::shared_ptr<ASTNode> c, std::vector<std::shared_ptr<ASTNode>> args)
    : callee(std::move(c)), arguments(std::move(args)) {
    type = ASTNodeType::CALL_EXPR;
}

// --- ReturnStmt Constructor ---
ReturnStmt::ReturnStmt(std::optional<std::shared_ptr<ASTNode>> v) : value(std::move(v)) {
    type = ASTNodeType::RETURN_STMT;
}

// --- StructDecl Constructor ---
StructDecl::StructDecl(const std::string& n, std::vector<std::string> f)
    : name(n), fields(std::move(f)) {
    type = ASTNodeType::STRUCT_DECL;
}

// --- ImportDecl Constructor ---
ImportDecl::ImportDecl(const std::string& m, std::optional<std::string> a)
    : module(m), alias(std::move(a)) {
    type = ASTNodeType::IMPORT_DECL;
}

std::string ast_to_string(const std::shared_ptr<ASTNode>& node) {
    if (!node) return "<null>";

    switch (node->type) {
        case ASTNodeType::LITERAL:
            return "Literal(" + static_cast<Literal*>(node.get())->value + ")";
        case ASTNodeType::VARIABLE:
            return "Variable(" + static_cast<Variable*>(node.get())->name + ")";
        case ASTNodeType::BINARY_OP: {
            auto bin = static_cast<BinaryOp*>(node.get());
            return "BinaryOp(" + bin->op + ", " + ast_to_string(bin->left) + ", " + ast_to_string(bin->right) + ")";
        }
        case ASTNodeType::UNARY_OP: {
            auto un = static_cast<UnaryOp*>(node.get());
            return "UnaryOp(" + un->op + ", " + ast_to_string(un->operand) + ")";
        }
        case ASTNodeType::DECLARATION: {
            auto decl = static_cast<Declaration*>(node.get());
            std::string out = "Declaration(";
            out += ast_to_string(decl->pattern);
            if (decl->type_annotation) {
                out += ": " + decl->type_annotation.value();
            }
            if (decl->initializer) {
                out += " = " + ast_to_string(decl->initializer.value());
            }
            out += ")";
            return out;
        }
        case ASTNodeType::VARIABLE_PATTERN: {
            auto p = static_cast<VariablePattern*>(node.get());
            return "VariablePattern(" + p->name + ")";
        }
        case ASTNodeType::TUPLE_PATTERN: {
            auto p = static_cast<TuplePattern*>(node.get());
            std::string result = "TuplePattern(";
            for (size_t i = 0; i < p->names.size(); ++i) {
                result += p->names[i];
                if (i + 1 < p->names.size()) result += ", ";
            }
            result += ")";
            return result;
        }
        case ASTNodeType::DESTRUCTURE_PATTERN: {
            auto p = static_cast<DestructurePattern*>(node.get());
            std::string result = (p->isArray ? "ArrayDestructure(" : "ObjectDestructure(");
            for (size_t i = 0; i < p->names.size(); ++i) {
                result += p->names[i];
                if (i + 1 < p->names.size()) result += ", ";
            }
            result += ")";
            return result;
        }
        case ASTNodeType::ASSIGNMENT: {
            auto assign = static_cast<Assignment*>(node.get());
            return "Assignment(" + assign->name + ", " + ast_to_string(assign->value) + ")";
        }
        case ASTNodeType::EXPRESSION_STMT: {
            auto expr = static_cast<ExpressionStmt*>(node.get());
            return "ExpressionStmt(" + ast_to_string(expr->expression) + ")";
        }
        case ASTNodeType::GUARD_STMT: {
            auto expr = static_cast<GuardStmt*>(node.get());
            return "GuardStmt(" + ast_to_string(expr->condition) + ", " + ast_to_string(expr->elseBranch) + ")";
        }
        case ASTNodeType::RETURN_STMT: {
            auto expr = static_cast<ReturnStmt*>(node.get());
            std::string v;
            if (expr->value) {
                v = ast_to_string(expr->value.value());
            }
            return "ReturnStmt(" + v + ")";
        }
        case ASTNodeType::BLOCK_STMT: {
            auto expr = static_cast<BlockStmt*>(node.get());

            std::string o = "";
            for (auto stmt : expr->statements) {
                o += ast_to_string(stmt);
            }
            return "BlockStmt(" + o + ")";
        }
        case ASTNodeType::IF_STMT: {
            auto expr = static_cast<IfStmt*>(node.get());
            return "IfStmt(" + ast_to_string(expr->condition) + ", " + ast_to_string(expr->thenBranch) + ")";
        }
        case ASTNodeType::FUNCTION_STMT: {
            auto expr = static_cast<FunctionStmt*>(node.get());
            std::string p = "";
            for (auto stmt : expr->params) {
                p += ast_to_string(stmt.first) + ": " + ast_to_string(stmt.second);
            }

            std::string c = "";
            for (auto stmt : expr->body) {
                c += ast_to_string(stmt) + "; ";
            }

            std::string ret = ast_to_string(expr->returnType.value_or(std::make_shared<ASTNode>(Variable("Any"))));

            return "FuncStmt(" + ast_to_string(expr->name) + ", (" + p + "), " + ret + ", {" + c + "})";
        }
        case ASTNodeType::CALL_EXPR: {
            auto expr = static_cast<CallExpr*>(node.get());
            std::string args = "";
            for (auto arg : expr->arguments) {
                args += ast_to_string(arg) + ", ";
            }
            return "CallExpr(" + ast_to_string(expr->callee) + ", (" + args + "))";
        }
        case ASTNodeType::META_STMT: {
            auto expr = static_cast<MetaStmt*>(node.get());
            std::string args = "";
            if (expr->arg.has_value()) {
                for (auto arg : expr->arg.value()) {
                    args += ast_to_string(arg) + ", ";
                }
            }

            return "MetaStmt(" + ast_to_string(expr->ns) + ", (" + args + "))";
        }
        default:
            return "<unhandled node type '" + std::to_string(static_cast<int>(node->type)) + "'>";
    }
}

# ```
# 

```./frontend/Token.hpp
#pragma once
#include <string>
#include <optional>
#include "Keyword.hpp"
#include "TokenType.hpp"

struct Token {
    std::string     lexeme  ;
    size_t          idx     ; // starting index
    TokenType       type    ;
    std::optional<Keyword> keyword; // Only used if type == TOK_KEYWORD
};

# ```
# 

```./frontend/Lexer.cpp
// lexer.cpp
#include "Lexer.hpp"
#include "TokenType.hpp"
#include "Token.hpp"
#include "match_keyword.hpp"

#include <cctype>
#include <optional>

Lexer::Lexer(const std::string& src)
    : source(src), current(0), start(0), length(src.size())
{}

std::vector<Token> Lexer::tokenize() {
    tokens.clear();
    while (!at_end()) {
        start = current;
        scan_token();
    }
    // EOF token
    tokens.push_back(Token{"", current, TOK_EOF, std::nullopt});
    return tokens;
}

bool Lexer::at_end() const {
    return current >= length;
}

char Lexer::advance() {
    return source[current++];
}

char Lexer::peek() const {
    return at_end() ? '\0' : source[current];
}

char Lexer::peek_next() const {
    return (current + 1 >= length) ? '\0' : source[current + 1];
}

bool Lexer::match(char expected) {
    if (at_end() || source[current] != expected) return false;
    current++;
    return true;
}

void Lexer::add_token(TokenType type) {
    add_token(type, source.substr(start, current - start));
}

void Lexer::add_token(TokenType type, const std::string& text) {
    tokens.push_back(Token{text, start, type, std::nullopt});
}

void Lexer::add_keyword_or_identifier() {
    std::string text = source.substr(start, current - start);
    if (auto kw = match_keyword(text)) {
        tokens.push_back(Token{text, start, TOK_KEYWORD, *kw});
    } else {
        tokens.push_back(Token{text, start, TOK_IDENTIFIER, std::nullopt});
    }
}

void Lexer::scan_token() {
    char c = advance();
    switch (c) {
        // Single-character tokens
        case '+': add_token(TOK_PLUS);        break;
        case '-': add_token(TOK_MINUS);       break;
        case '*': add_token(TOK_ASTERISK);    break;
        case '/':
            if (match('/')) {
                // skip comment until end of line
                while (peek() != '\n' && !at_end()) advance();
            } else {
                add_token(TOK_SLASH);
            }
            break;
        case '%': add_token(TOK_PERCENT);     break;
        case '(': add_token(TOK_LPAREN);      break;
        case ')': add_token(TOK_RPAREN);      break;
        case '[': add_token(TOK_LBRACKET);      break;
        case ']': add_token(TOK_RBRACKET);      break;
        case '{': add_token(TOK_LBRACE);      break;
        case '}': add_token(TOK_RBRACE);      break;
        case ',': add_token(TOK_COMMA);       break;
        case '.': add_token(TOK_DOT);         break;
        case ';': add_token(TOK_SEMICOLON);   break;
        case ':': add_token(TOK_COLON);   break;

        // One or two character tokens
        case '=': add_token(match('=') ? TOK_EQUAL         : TOK_ASSIGN);       break;
        case '!': add_token(match('=') ? TOK_NOT_EQUAL     : TOK_NOT);          break;
        case '<': add_token(match('=') ? TOK_LESS_EQUAL    : TOK_LESS);         break;
        case '>': add_token(match('=') ? TOK_GREATER_EQUAL : TOK_GREATER);      break;
        case '&': add_token(match('&') ? TOK_AND           : TOK_UNKNOWN);      break;
        case '|': add_token(match('|') ? TOK_OR            : TOK_UNKNOWN);      break;

        // Whitespace
        case ' ':
        case '\r':
        case '\t':
        case '\n':
            break; // skip

        // String literals
        case '"': string();  break;

        default:
            if (std::isdigit(c)) {
                number();
            } else if (std::isalpha(c) || c == '_') {
                identifier();
            } else {
                add_token(TOK_UNKNOWN);
            }
    }
}

void Lexer::string() {
    // consume until closing quote
    while (peek() != '"' && !at_end()) {
        if (peek() == '\\' && peek_next() != '\0') {
            // skip escape sequence
            advance();
        }
        advance();
    }

    if (at_end()) {
        // Unterminated string; still emit what we have
        add_token(TOK_STRING);
        return;
    }

    // closing "
    advance();
    add_token(TOK_STRING, source.substr(start, current - start));
}

void Lexer::number() {
    // integer part
    while (std::isdigit(peek())) advance();

    // fractional part
    if (peek() == '.' && std::isdigit(peek_next())) {
        advance(); // consume '.'
        while (std::isdigit(peek())) advance();
        add_token(TOK_DECIMAL);
    } else {
        add_token(TOK_INTEGER);
    }
}

void Lexer::identifier() {
    while (std::isalnum(peek()) || peek() == '_') {
        advance();
    }
    add_keyword_or_identifier();
}

# ```
# 

```./frontend/Lexer.hpp
#pragma once
#include <string>
#include <vector>
#include "Keyword.hpp"
#include "match_keyword.hpp"
#include "Token.hpp"

class Lexer {
public:
    explicit Lexer(const std::string& src);

    std::vector<Token> tokenize();

private:
    const std::string& source;
    size_t current = 0;
    size_t start   = 0;
    size_t length  = 0;

    std::vector<Token> tokens;

    // --- Core advancing functions
    bool at_end() const;
    char advance();
    char peek() const;
    char peek_next() const;
    bool match(char expected);

    // --- Token creation
    void add_token(TokenType type);
    void add_token(TokenType type, const std::string& text);
    void add_keyword_or_identifier();

    // --- Handlers
    void scan_token();
    void string();
    void number();
    void identifier();
};

# ```
# 

```./frontend/match_keyword.hpp
#pragma once
#include <string>
#include <optional>
#include "Keyword.hpp"

std::optional<Keyword> match_keyword(const std::string& word);

# ```
# 

```./frontend/Desugarer.hpp
#pragma once
#include <vector>
#include <memory>
#include "AST.hpp"

// The Desugarer rewrites complex AST nodes into simpler forms
class Desugarer {
public:
    std::vector<std::shared_ptr<ASTNode>>& ast;
    Desugarer(std::vector<std::shared_ptr<ASTNode>>& ast);
    std::vector<std::shared_ptr<ASTNode>> desugar();

private:
    // Internal recursive helpers
    static std::shared_ptr<ASTNode> desugar_node(std::shared_ptr<ASTNode> node);

    static std::shared_ptr<ASTNode> desugar_declaration(std::shared_ptr<Declaration> decl);
    static std::shared_ptr<ASTNode> desugar_assignment(std::shared_ptr<Assignment> assign);
    static std::shared_ptr<ASTNode> desugar_expression_stmt(std::shared_ptr<ExpressionStmt> expr_stmt);
    static std::shared_ptr<ASTNode> desugar_if_stmt(std::shared_ptr<IfStmt> if_stmt);
    static std::shared_ptr<ASTNode> desugar_guard_stmt(std::shared_ptr<GuardStmt> guard_stmt);
    static std::shared_ptr<ASTNode> desugar_while_stmt(std::shared_ptr<WhileStmt> while_stmt);
    static std::shared_ptr<ASTNode> desugar_block_stmt(std::shared_ptr<BlockStmt> block_stmt);
    static std::shared_ptr<ASTNode> desugar_func_decl(std::shared_ptr<FunctionStmt> func_decl);
    static std::shared_ptr<ASTNode> desugar_return_stmt(std::shared_ptr<ReturnStmt> return_stmt);
    static std::shared_ptr<ASTNode> desugar_struct_decl(std::shared_ptr<StructDecl> struct_decl);
    static std::shared_ptr<ASTNode> desugar_import_decl(std::shared_ptr<ImportDecl> import_decl);
    static std::shared_ptr<ASTNode> desugar_call_expr(std::shared_ptr<CallExpr> call_expr);

    // Utility: flatten multiple statements into a block
    static std::shared_ptr<BlockStmt> flatten(const std::vector<std::shared_ptr<ASTNode>>& stmts);
};

# ```
# 

```./frontend/Parser.cpp
#include <iostream>
#include "Parser.hpp"
#include "AST.hpp"
#include "TokenType.hpp"
#include <memory>
#include <optional>
#include <stdexcept>

Parser::Parser(const std::vector<Token>& tokens)
    : tokens(tokens), current(0) {}

std::vector<std::shared_ptr<ASTNode>> Parser::parse() {
    std::vector<std::shared_ptr<ASTNode>> statements;
    while (!at_end()) {
        statements.push_back(parse_statement());
    }
    return statements;
}

bool Parser::at_end() const {
    return peek().type == TOK_EOF;
}

const Token& Parser::peek() const {
    return tokens[current];
}

const Token& Parser::previous() const {
    return tokens[current - 1];
}

const Token& Parser::advance() {
    if (!at_end()) current++;
    return previous();
}

bool Parser::check(TokenType type) const {
    if (at_end()) return false;
    return peek().type == type;
}

bool Parser::match(std::initializer_list<TokenType> types) {
    for (auto t : types) {
        if (check(t)) {
            advance();
            return true;
        }
    }
    return false;
}

Token Parser::consume(TokenType type, const std::string& error_message) {
    if (check(type)) return advance();
    throw std::runtime_error(error_message);
}

void Parser::synchronize() {
    while (!at_end() && peek().type != TOK_SEMICOLON) {
        advance();
    }
    if (check(TOK_SEMICOLON)) advance();
}

std::shared_ptr<BlockStmt> Parser::parse_block() {
    consume(TOK_LBRACE, "Expected '{'");
    std::vector<std::shared_ptr<ASTNode>> stmts;
    while (!check(TOK_RBRACE) && !at_end()) {
        stmts.push_back(parse_statement());
    }
    consume(TOK_RBRACE, "Expected '}'");
    return std::make_shared<BlockStmt>(std::move(stmts));
}

std::vector<Token> Parser::collect_until_keyword_or(TokenType stop, const std::string& keyword) {
    std::vector<Token> out;
    int brace_depth = 0;
    int paren_depth = 0;
    while (!at_end()) {
        if (peek().type == TOK_LBRACE) brace_depth++;
        else if (peek().type == TOK_RBRACE) brace_depth--;
        else if (peek().type == TOK_LPAREN) paren_depth++;
        else if (peek().type == TOK_RPAREN) paren_depth--;
        if (brace_depth == 0 && paren_depth == 0 && peek().type == stop && peek().lexeme == keyword) {
            break;
        }
        out.push_back(advance());
    }
    return out;
}

std::shared_ptr<ASTNode> Parser::parse_head(const std::vector<Token>& head_tokens) {
    Parser sub(head_tokens);
    return sub.parse_expression();
}

std::shared_ptr<ASTNode> Parser::parse_statement() {
    if (match({TOK_LBRACE})) {
        return parse_block_no_open(); // parse block statement
    }

    if (check(TOK_KEYWORD)) {
        auto kw = peek().keyword.value();
        if (kw == Keyword::KW_LET) return parse_let();
        if (kw == Keyword::KW_GUARD) return parse_guard();
        if (kw == Keyword::KW_RETURN) return parse_return();
        if (kw == Keyword::KW_META) return parse_meta();
        if (kw == Keyword::KW_FUNC) return parse_function();
    }

    // assignment
    if (check(TOK_IDENTIFIER) && tokens[current + 1].type == TOK_ASSIGN) {
        Token name = advance();
        advance();
        auto value = parse_expression();
        consume(TOK_SEMICOLON, "Expected ';'");
        return std::make_shared<Assignment>(name.lexeme, value);
    }

    // call
    if (check(TOK_IDENTIFIER) && tokens[current + 1].type == TOK_LPAREN) {
        Token callee_name = advance(); // consume identifier
        auto iden = std::make_shared<Variable>(callee_name.lexeme);
        auto call = parse_call(iden);
        auto call_expr = std::dynamic_pointer_cast<CallExpr>(call);
        consume(TOK_SEMICOLON, "Expected ';'");
        return call_expr;
    }

    // accessor
    if (check(TOK_IDENTIFIER) && tokens[current + 1].type == TOK_DOT) {
        std::cerr << "Accessor Error. Not Implemented Yet." << std::endl;
        exit(5);
    }

    auto expr = parse_expression();
    consume(TOK_SEMICOLON, "Expected ';'");
    return std::make_shared<ExpressionStmt>(expr);
}

std::shared_ptr<ASTNode> Parser::parse_let() {
    consume(TOK_KEYWORD, "Expected 'let'");

    std::shared_ptr<ASTNode> pattern;

    // Handle destructuring patterns: {x, y} or [x, y]
    if (match({TOK_LBRACE})) {
        std::vector<std::string> names;
        do {
            Token name = consume(TOK_IDENTIFIER, "Expected identifier in destructuring");
            names.push_back(name.lexeme);
        } while (match({TOK_COMMA}));
        consume(TOK_RBRACE, "Expected '}' after destructuring pattern");

        pattern = std::make_shared<DestructurePattern>(names, /* isArray = */ false);
    } else if (match({TOK_LBRACKET})) {
        std::vector<std::string> names;
        do {
            Token name = consume(TOK_IDENTIFIER, "Expected identifier in destructuring");
            names.push_back(name.lexeme);
        } while (match({TOK_COMMA}));
        consume(TOK_RBRACKET, "Expected ']' after destructuring pattern");

        pattern = std::make_shared<DestructurePattern>(names, /* isArray = */ true);
    } else if (match({TOK_LPAREN})) {
        // Optional: support tuple grouping
        std::vector<std::string> names;
        do {
            Token name = consume(TOK_IDENTIFIER, "Expected identifier in tuple pattern");
            names.push_back(name.lexeme);
        } while (match({TOK_COMMA}));
        consume(TOK_RPAREN, "Expected ')' after tuple pattern");

        pattern = std::make_shared<TuplePattern>(names);
    } else {
        // Normal single-variable declaration
        Token name = consume(TOK_IDENTIFIER, "Expected identifier after 'let'");
        pattern = std::make_shared<VariablePattern>(name.lexeme);
    }

    // Optional type annotation
    std::optional<std::string> type_annotation;
    if (match({TOK_COLON})) {
        Token typeName = consume(TOK_IDENTIFIER, "Expected type name after ':'");
        type_annotation = typeName.lexeme;
    }

    // Optional initializer
    std::optional<std::shared_ptr<ASTNode>> initializer;
    if (match({TOK_ASSIGN})) {
        initializer = parse_expression();
    }

    consume(TOK_SEMICOLON, "Expected ';' after variable declaration");

    return std::make_shared<Declaration>(pattern, type_annotation, initializer);
}

std::shared_ptr<ASTNode> Parser::parse_function() {
    consume(TOK_KEYWORD, "Expected 'func' keyword.");

    auto name = std::make_shared<Variable>(consume(TOK_IDENTIFIER, "Expected function name.").lexeme);

    consume(TOK_LPAREN, "Expected '(' after function name.");

    std::vector<std::pair<std::shared_ptr<ASTNode>, std::shared_ptr<ASTNode>>> params;

    if (!check(TOK_RPAREN)) {
        do {
            auto paramName = std::make_shared<Variable>(consume(TOK_IDENTIFIER, "Expected parameter name.").lexeme);
            consume(TOK_COLON, "Expected ':' after parameter name.");
            auto paramType = std::make_shared<Variable>(consume(TOK_IDENTIFIER, "Expected parameter type.").lexeme);

            params.emplace_back(paramName, paramType);
        } while (match({TOK_COMMA}));
    }

    consume(TOK_RPAREN, "Expected ')' after parameters.");

    std::optional<std::shared_ptr<ASTNode>> returnType = std::nullopt;
    if (match({TOK_COLON})) {
        auto returnTypeNode = std::make_shared<Variable>(consume(TOK_IDENTIFIER, "Expected return type.").lexeme);
        returnType = returnTypeNode;
    }

    if (!check(TOK_LBRACE)) throw std::runtime_error("Expected '{' before function body.");

    auto block = parse_block();

    return std::make_shared<FunctionStmt>(
        std::move(name),
        std::move(params),
        std::move(returnType),
        std::move(block->statements)
    );

}

std::shared_ptr<ASTNode> Parser::parse_guard() {
    consume(TOK_KEYWORD, "Expected 'guard'");
    auto condition = parse_expression();
    Token e = consume(TOK_KEYWORD, "Expected 'else'");
    if (e.lexeme != "else") throw std::runtime_error("Expected 'else'");

    std::shared_ptr<ASTNode> else_branch;

    if (check(TOK_LBRACE)) {
        else_branch = parse_block();
        match({TOK_SEMICOLON});
    } else {
        auto ex = parse_expression();
        else_branch = std::make_shared<ReturnStmt>(ex);
        consume(TOK_SEMICOLON, "Expected ';'");
    }

    return std::make_shared<GuardStmt>(condition, else_branch);
}

std::shared_ptr<BlockStmt> Parser::parse_block_no_open() {
    // DO NOT consume '{'  it was already matched before calling this function
    std::vector<std::shared_ptr<ASTNode>> stmts;
    while (!check(TOK_RBRACE) && !at_end()) {
        stmts.push_back(parse_statement());
    }
    consume(TOK_RBRACE, "Expected '}'");
    return std::make_shared<BlockStmt>(std::move(stmts));
}

// Assumes '{' has already been consumed
std::shared_ptr<BlockStmt> Parser::parse_block_already_open() {
    std::vector<std::shared_ptr<ASTNode>> stmts;
    while (!check(TOK_RBRACE) && !at_end()) {
        stmts.push_back(parse_statement());
    }
    consume(TOK_RBRACE, "Expected '}'");
    return std::make_shared<BlockStmt>(std::move(stmts));
}

std::shared_ptr<ASTNode> Parser::parse_return() {
    consume(TOK_KEYWORD, "Expected 'return'");
    std::optional<std::shared_ptr<ASTNode>> value;
    if (!check(TOK_SEMICOLON)) {
        value = parse_expression();
    }
    consume(TOK_SEMICOLON, "Expected ';' after return");
    return std::make_shared<ReturnStmt>(value);
}

std::shared_ptr<ASTNode> Parser::parse_meta() {
    auto ns = std::make_shared<Variable>(consume(TOK_KEYWORD, "Expected 'Meta'.").lexeme);
    consume(TOK_DOT, "Expected '.' after 'Meta' keyword.");

    auto accessor = std::make_shared<Variable>(consume(TOK_IDENTIFIER, "Expected identifier.").lexeme);

    auto a_ns = std::static_pointer_cast<ASTNode>(ns);
    auto a_accessor = std::static_pointer_cast<ASTNode>(accessor);

    if (check(TOK_LPAREN)) {
        auto call = parse_call(accessor); // returns shared_ptr<ASTNode>
        consume(TOK_SEMICOLON, "Expected ';'");

        // Downcast to CallExpr
        auto call_expr = std::dynamic_pointer_cast<CallExpr>(call);
        if (!call_expr) {
            throw std::runtime_error("Expected function call after Meta accessor.");
        }

        return std::make_shared<MetaStmt>(
            a_ns,
            a_accessor,
            call_expr->arguments
        );
    } else if (check(TOK_SEMICOLON)) {
        consume(TOK_SEMICOLON, "Expected ';'");

        return std::make_shared<MetaStmt>(
            a_ns,
            a_accessor
        );
    } else {
        throw std::runtime_error("Unexpected token after 'Meta' accessor: '" + peek().lexeme + "'");
    }
}

std::shared_ptr<ASTNode> Parser::parse_expression() {
    return parse_assignment();
}


std::shared_ptr<ASTNode> Parser::parse_assignment() {
    auto node = parse_or();

    if (match({TOK_ASSIGN})) {
        Token equals = previous();
        auto value = parse_assignment(); // right-associative!

        if (auto var = std::dynamic_pointer_cast<Variable>(node)) {
            return std::make_shared<Assignment>(var->name, value);
        } else {
            throw std::runtime_error("Invalid assignment target");
        }
    }

    return node;
}

std::shared_ptr<ASTNode> Parser::parse_or() {
    auto node = parse_and();
    while (match({TOK_OR})) {
        Token op = previous();
        auto right = parse_and();
        node = std::make_shared<BinaryOp>(op.lexeme, node, right);
    }
    return node;
}

std::shared_ptr<ASTNode> Parser::parse_and() {
    auto node = parse_equality();
    while (match({TOK_AND})) {
        Token op = previous();
        auto right = parse_equality();
        node = std::make_shared<BinaryOp>(op.lexeme, node, right);
    }
    return node;
}

std::shared_ptr<ASTNode> Parser::parse_equality() {
    auto node = parse_comparison();
    while (match({TOK_EQUAL, TOK_NOT_EQUAL})) {
        Token op = previous();
        auto right = parse_comparison();
        node = std::make_shared<BinaryOp>(op.lexeme, node, right);
    }
    return node;
}

std::shared_ptr<ASTNode> Parser::parse_comparison() {
    auto node = parse_term();
    while (match({TOK_LESS, TOK_LESS_EQUAL, TOK_GREATER, TOK_GREATER_EQUAL})) {
        Token op = previous();
        auto right = parse_term();
        node = std::make_shared<BinaryOp>(op.lexeme, node, right);
    }
    return node;
}

std::shared_ptr<ASTNode> Parser::parse_term() {
    auto node = parse_factor();
    while (match({TOK_PLUS, TOK_MINUS})) {
        Token op = previous();
        auto right = parse_factor();
        node = std::make_shared<BinaryOp>(op.lexeme, node, right);
    }
    return node;
}

std::shared_ptr<ASTNode> Parser::parse_factor() {
    auto node = parse_unary();
    while (match({TOK_ASTERISK, TOK_SLASH, TOK_PERCENT})) {
        Token op = previous();
        auto right = parse_unary();
        node = std::make_shared<BinaryOp>(op.lexeme, node, right);
    }
    return node;
}

std::shared_ptr<ASTNode> Parser::parse_unary() {
    if (match({TOK_MINUS, TOK_NOT})) {
        Token op = previous();
        auto operand = parse_unary();
        return std::make_shared<UnaryOp>(op.lexeme, operand);
    }
    return parse_primary();
}

std::shared_ptr<ASTNode> Parser::parse_primary() {
    if (match({TOK_INTEGER, TOK_DECIMAL, TOK_STRING})) {
        return std::make_shared<Literal>(previous().lexeme);
    }
    if (match({TOK_KEYWORD})) {
        auto kw = previous().keyword.value();
        if (kw == Keyword::KW_TRUE || kw == Keyword::KW_FALSE || kw == Keyword::KW_NULL) {
            return std::make_shared<Literal>(previous().lexeme);
        }

        if (kw == Keyword::KW_META) {
            // Special handling for Meta
            auto meta_ns = std::make_shared<Variable>("Meta");
            consume(TOK_DOT, "Expected '.' after 'Meta'");
            auto accessor = std::make_shared<Variable>(consume(TOK_IDENTIFIER, "Expected Meta accessor").lexeme);

            // If it's a function call (Meta.Time()), parse call
            if (check(TOK_LPAREN)) {
                auto call = parse_call(accessor);
                auto call_expr = std::dynamic_pointer_cast<CallExpr>(call);
                if (!call_expr) throw std::runtime_error("Expected function call after Meta accessor.");

                return std::make_shared<MetaStmt>(
                    std::static_pointer_cast<ASTNode>(meta_ns),
                    std::static_pointer_cast<ASTNode>(accessor),
                    call_expr->arguments
                );
            }
            // If just property access (Meta.Something)
            else {
                return std::make_shared<MetaStmt>(
                    std::static_pointer_cast<ASTNode>(meta_ns),
                    std::static_pointer_cast<ASTNode>(accessor)
                );
            }
        }
        throw std::runtime_error("Unexpected keyword '" + previous().lexeme + "'");
    }
    if (match({TOK_IDENTIFIER})) {
        std::shared_ptr<ASTNode> expr = std::make_shared<Variable>(previous().lexeme);

        while (match({TOK_DOT})) {
            Token name = consume(TOK_IDENTIFIER, "Expected property name after '.'");
            expr = std::make_shared<FieldAccess>(expr, name.lexeme);
        }

        if (check(TOK_LPAREN)) {
            expr = parse_call(expr);
        }

        return expr;
    }
    if (match({TOK_LPAREN})) {
        auto expr = parse_expression();
        consume(TOK_RPAREN, "Expected ')'");
        return expr;
    }
    throw std::runtime_error("Unexpected token: " + peek().lexeme);
}


std::shared_ptr<ASTNode> Parser::parse_call(std::shared_ptr<ASTNode> callee) {
    consume(TOK_LPAREN, "Expected '(' after function name");

    std::vector<std::shared_ptr<ASTNode>> arguments;

    if (!check(TOK_RPAREN)) {
        do {
            arguments.push_back(parse_expression());
        } while (match({TOK_COMMA}));
    }

    consume(TOK_RPAREN, "Expected ')' after arguments");

    return std::make_shared<CallExpr>(callee, arguments);
}

# ```
# 

```./frontend/AST.hpp
#pragma once

#include <string>
#include <memory>
#include <vector>
#include <optional>

// --- AST Node Types ---
enum class ASTNodeType {
    LITERAL,
    VARIABLE,
    BINARY_OP,
    UNARY_OP,
    DECLARATION,
    VARIABLE_PATTERN,
    TUPLE_PATTERN,
    DESTRUCTURE_PATTERN,
    ASSIGNMENT,
    EXPRESSION_STMT,
    PRINT_STMT,
    IF_STMT,
    META_STMT,
    GUARD_STMT,
    WHILE_STMT,
    FOR_IN_STMT,
    BLOCK_STMT,
    FUNCTION_STMT,
    CALL_EXPR,
    RETURN_STMT,
    STRUCT_DECL,
    IMPORT_DECL
};

// --- Base AST Node ---
struct ASTNode {
    ASTNodeType type;
    virtual ~ASTNode();
};

// --- Literal Node ---
struct Literal : ASTNode {
    std::string value;
    explicit Literal(const std::string& val);
    bool is_str();
    bool is_int();
    bool is_dec();
};

// --- Variable Reference Node ---
struct Variable : ASTNode {
    std::string name;
    explicit Variable(const std::string& n);
};

// --- Binary Operation Node ---
struct BinaryOp : ASTNode {
    std::string op;
    std::shared_ptr<ASTNode> left, right;
    BinaryOp(const std::string& oper,
             std::shared_ptr<ASTNode> lhs,
             std::shared_ptr<ASTNode> rhs);
};

// --- Unary Operation Node ---
struct UnaryOp : ASTNode {
    std::string op;
    std::shared_ptr<ASTNode> operand;
    UnaryOp(const std::string& oper,
            std::shared_ptr<ASTNode> opd);
};

// --- Declaration (let or const) Node ---
struct Declaration : public ASTNode {
    std::shared_ptr<ASTNode> pattern;
    std::optional<std::string> type_annotation;
    std::optional<std::shared_ptr<ASTNode>> initializer;

    Declaration(std::shared_ptr<ASTNode> pattern,
                std::optional<std::string> type_annotation,
                std::optional<std::shared_ptr<ASTNode>> initializer);
};

// --- VariablePattern Node ---
struct VariablePattern : public ASTNode {
    std::string name;

    VariablePattern(const std::string& name);
};

// --- TuplePattern Node ---
struct TuplePattern : public ASTNode {
    std::vector<std::string> names;

    TuplePattern(std::vector<std::string> names);
};

// --- DestructurePattern Node ---
struct DestructurePattern : public ASTNode {
    std::vector<std::string> names;
    bool isArray; // true = array destructuring, false = object destructuring

    DestructurePattern(std::vector<std::string> names, bool isArray);
};

// --- Assignment Node ---
struct Assignment : ASTNode {
    std::string name;
    std::shared_ptr<ASTNode> value;
    Assignment(const std::string& n,
               std::shared_ptr<ASTNode> val);
};

// --- Expression Statement Node ---
struct ExpressionStmt : ASTNode {
    std::shared_ptr<ASTNode> expression;
    explicit ExpressionStmt(std::shared_ptr<ASTNode> expr);
};

// --- If Statement Node ---
struct IfStmt : ASTNode {
    std::shared_ptr<ASTNode> condition;
    std::shared_ptr<ASTNode> thenBranch;
    std::vector<std::shared_ptr<ASTNode>> elifBranches;
    std::optional<std::shared_ptr<ASTNode>> elseBranch;

    IfStmt(std::shared_ptr<ASTNode> cond,
           std::shared_ptr<ASTNode> thenB,
           std::vector<std::shared_ptr<ASTNode>> elifB = {},
           std::optional<std::shared_ptr<ASTNode>> elseB = std::nullopt);
};

// --- Meta NS Call ---
//  e.g. Meta::RAW_EMIT("(WRITE)");
struct MetaStmt : ASTNode {
    std::shared_ptr<ASTNode> ns; // namespace (i.e. 'Meta')
    std::shared_ptr<ASTNode> call; // e.g. 'RAW_EMIT'
    std::optional<std::vector<std::shared_ptr<ASTNode>>> arg; // if set, call function; else treat as var

    MetaStmt(
        std::shared_ptr<ASTNode> ns,
        std::shared_ptr<ASTNode> call,
        std::optional<std::vector<std::shared_ptr<ASTNode>>> arg
    );

    MetaStmt(
        std::shared_ptr<ASTNode> ns,
        std::shared_ptr<ASTNode> call
    );
};

struct ElifBranch : ASTNode {
    std::shared_ptr<ASTNode> condition;
    std::shared_ptr<ASTNode> thenBranch;
};

// --- Guard Statement Node ---
struct GuardStmt : ASTNode {
    std::shared_ptr<ASTNode> condition;
    std::shared_ptr<ASTNode> elseBranch;
    GuardStmt(std::shared_ptr<ASTNode> cond,
           std::shared_ptr<ASTNode> elseB);
};

// --- While Statement Node ---
struct WhileStmt : ASTNode {
    std::shared_ptr<ASTNode> condition;
    std::shared_ptr<ASTNode> body;
    WhileStmt(std::shared_ptr<ASTNode> cond,
              std::shared_ptr<ASTNode> b);
};

// --- For-In Statement Node ---
struct ForInStmt : ASTNode {
    std::string varName;
    std::shared_ptr<ASTNode> iterable;
    std::shared_ptr<ASTNode> body;
    ForInStmt(const std::string& n,
              std::shared_ptr<ASTNode> iter,
              std::shared_ptr<ASTNode> b);
};

// --- Block Statement Node ---
struct BlockStmt : ASTNode {
    std::vector<std::shared_ptr<ASTNode>> statements;
    explicit BlockStmt(std::vector<std::shared_ptr<ASTNode>> stmts);
};

// --- Function Declaration Node ---
struct FunctionStmt : ASTNode {
    std::shared_ptr<ASTNode> name;
    std::vector<std::pair<std::shared_ptr<ASTNode>, std::shared_ptr<ASTNode>>> params; // (paramName, paramType)
    std::optional<std::shared_ptr<ASTNode>> returnType;
    std::vector<std::shared_ptr<ASTNode>> body; // Function body block

    FunctionStmt(
        std::shared_ptr<ASTNode> name,
        std::vector<std::pair<std::shared_ptr<ASTNode>, std::shared_ptr<ASTNode>>> params,
        std::optional<std::shared_ptr<ASTNode>> returnType,
        std::vector<std::shared_ptr<ASTNode>> body
    );
};

// --- Access Node (e.g. "Math.sin") ---
struct FieldAccess : ASTNode {
    std::shared_ptr<ASTNode> object;
    std::string field;

    FieldAccess(std::shared_ptr<ASTNode> object, const std::string& field);
};

// --- Call Expression Node ---
struct CallExpr : ASTNode {
    std::shared_ptr<ASTNode> callee;
    std::vector<std::shared_ptr<ASTNode>> arguments;
    CallExpr(std::shared_ptr<ASTNode> c,
             std::vector<std::shared_ptr<ASTNode>> args);
};

// --- Return Statement Node ---
struct ReturnStmt : ASTNode {
    std::optional<std::shared_ptr<ASTNode>> value;
    explicit ReturnStmt(std::optional<std::shared_ptr<ASTNode>> v = std::nullopt);
};

// --- Struct Declaration Node ---
struct StructDecl : ASTNode {
    std::string name;
    std::vector<std::string> fields;
    StructDecl(const std::string& n,
               std::vector<std::string> f);
};

// --- Import Declaration Node ---
struct ImportDecl : ASTNode {
    std::string module;
    std::optional<std::string> alias;
    ImportDecl(const std::string& m,
               std::optional<std::string> a = std::nullopt);
};

std::string ast_to_string(const std::shared_ptr<ASTNode>& node);

# ```
# 

```./vm/obj/Integer.hpp
#pragma once
#include "Scalar.hpp"

class Integer : public Scalar {
public:
    int64_t value;
    Integer(int64_t v);

    std::string __str__() const override;
    bool __bool__() const override;
    std::string __name__() const override;

    std::shared_ptr<Object> __add__(const Object& o) const override;
    std::shared_ptr<Object> __sub__(const Object& o) const override;
    std::shared_ptr<Object> __mul__(const Object& o) const override;
    std::shared_ptr<Object> __div__(const Object& o) const override;
    std::shared_ptr<Object> __mod__(const Object& o) const override;

    std::shared_ptr<Object> __eq__ (const Object& o) const override;
    std::shared_ptr<Object> __lt__ (const Object& o) const override;
    std::shared_ptr<Object> __gt__ (const Object& o) const override;
    std::shared_ptr<Object> __le__ (const Object& o) const override;
    std::shared_ptr<Object> __ge__ (const Object& o) const override;
    std::shared_ptr<Object> __and__(const Object& o) const override;
    std::shared_ptr<Object> __or__ (const Object& o) const override;
    std::shared_ptr<Object> __not__() const override;
};

# ```
# 

```./vm/obj/Boolean.hpp
#pragma once
#include "Object.hpp"

class Boolean : public Object {
public:
    bool value;
    Boolean(bool v);

    std::string __str__() const override;
    bool __bool__() const override;
    std::string __name__() const override;

    std::shared_ptr<Object> __eq__ (const Object& o) const override;
    std::shared_ptr<Object> __and__ (const Object& o) const override;
    std::shared_ptr<Object> __or__ (const Object& o) const override;
    std::shared_ptr<Object> __not__ () const override;
};

# ```
# 

```./vm/obj/Decimal.cpp
#include "Decimal.hpp"
#include "Integer.hpp"
#include "Boolean.hpp"
#include "String.hpp"
#include <memory>

Decimal::Decimal(double v) : value(v) {}

std::string Decimal::__str__() const {
    return std::to_string(value);
}

bool Decimal::__bool__() const {
    return value != 0.0;
}

std::string Decimal::__name__() const {
    return "decimal";
}

std::shared_ptr<Object> Decimal::__add__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Decimal>(value + p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Decimal>(value + static_cast<double>(p->value));
    }
    if (const auto* p = dynamic_cast<const String*>(&o)) {
        return std::make_shared<String>(__str__() + p->value);
    }
    throw std::runtime_error("TypeError: decimal + " + o.__name__());
}

std::shared_ptr<Object> Decimal::__sub__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Decimal>(value - p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Decimal>(value - static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: decimal - " + o.__name__());
}

std::shared_ptr<Object> Decimal::__mul__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Decimal>(value * p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Decimal>(value * static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: decimal * " + o.__name__());
}

std::shared_ptr<Object> Decimal::__div__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        if (p->value == 0.0) throw std::runtime_error("ZeroDivisionError: decimal / decimal");
        return std::make_shared<Decimal>(value / p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        if (p->value == 0) throw std::runtime_error("ZeroDivisionError: decimal / integer");
        return std::make_shared<Decimal>(value / static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: decimal / " + o.__name__());
}

std::shared_ptr<Object> Decimal::__eq__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Boolean>(value == p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value == static_cast<double>(p->value));
    }
    return std::make_shared<Boolean>(false);
}

std::shared_ptr<Object> Decimal::__lt__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Boolean>(value < p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value < static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: decimal < " + o.__name__());
}

std::shared_ptr<Object> Decimal::__gt__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Boolean>(value > p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value > static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: decimal > " + o.__name__());
}

std::shared_ptr<Object> Decimal::__le__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Boolean>(value <= p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value <= static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: decimal <= " + o.__name__());
}

std::shared_ptr<Object> Decimal::__ge__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Boolean>(value >= p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value >= static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: decimal >= " + o.__name__());
}


std::shared_ptr<Object> Decimal::__or__(const Object& o) const {
    return std::make_shared<Boolean>(__bool__() || o.__bool__());
}
std::shared_ptr<Object> Decimal::__and__(const Object& o) const {
    return std::make_shared<Boolean>(__bool__() && o.__bool__());
}
std::shared_ptr<Object> Decimal::__not__() const {
    return std::make_shared<Boolean>(!__bool__());
}

# ```
# 

```./vm/obj/RegEx.hpp
#pragma once
#include "String.hpp"
#include <set>

class RegEx : public String {
public:
    std::set<char> flags;

    RegEx(const std::string& pattern, const std::set<char>& flags = {});

    std::string __name__() const override;

    bool has_flag(char flag) const;
};

# ```
# 

```./vm/obj/Scalar.cpp
#include "Scalar.hpp"

# ```
# 

```./vm/obj/Object.cpp
#include "Object.hpp"
#include <stdexcept>

std::shared_ptr<Object> Object::__add__ (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for +"); }
std::shared_ptr<Object> Object::__sub__ (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for -"); }
std::shared_ptr<Object> Object::__mul__ (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for *"); }
std::shared_ptr<Object> Object::__div__ (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for /"); }
std::shared_ptr<Object> Object::__mod__ (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for %"); }
std::shared_ptr<Object> Object::__eq__  (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for =="); }
std::shared_ptr<Object> Object::__lt__  (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for <"); }
std::shared_ptr<Object> Object::__gt__  (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for >"); }
std::shared_ptr<Object> Object::__le__  (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for <="); }
std::shared_ptr<Object> Object::__ge__  (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for >="); }
std::shared_ptr<Object> Object::__or__  (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for ||"); }
std::shared_ptr<Object> Object::__and__  (const Object& o) const { throw std::runtime_error("Unsupported operand type(s) for &&"); }
std::shared_ptr<Object> Object::__not__  () const { throw std::runtime_error("Unsupported operand type(s) for !"); }

std::shared_ptr<Object> Object::__iter__() const { throw std::runtime_error("Object is not iterable"); }
std::shared_ptr<Object> Object::__next__()       { throw std::runtime_error("Iteration not supported"); }

# ```
# 

```./vm/obj/Undefined.cpp
#include "Undefined.hpp"
#include "Boolean.hpp"
#include "String.hpp"
#include <memory>

Undefined::Undefined() {}

std::string Undefined::__str__() const {
    return "undefined";
}

bool Undefined::__bool__() const {
    return false;
}

std::string Undefined::__name__() const {
    return "undefined";
}

std::shared_ptr<Object> Undefined::__add__(const Object& o) const {
    return std::make_shared<String>("undefined" + o.__str__());
}

std::shared_ptr<Object> Undefined::__eq__(const Object& o) const {
    return std::make_shared<Boolean>(false);
}

# ```
# 

```./vm/obj/Scientific.hpp
#pragma once
#include "Scalar.hpp"
#include <string>

class Scientific : public Scalar {
public:
    double value;

    Scientific(double v);

    std::string __str__() const override;
    bool __bool__() const override;
    std::string __name__() const override;

    std::shared_ptr<Object> __add__ (const Object& o) const override;
    std::shared_ptr<Object> __sub__ (const Object& o) const override;
    std::shared_ptr<Object> __mul__ (const Object& o) const override;
    std::shared_ptr<Object> __div__ (const Object& o) const override;

    std::shared_ptr<Object> __eq__  (const Object& o) const override;
    std::shared_ptr<Object> __lt__  (const Object& o) const override;
    std::shared_ptr<Object> __gt__  (const Object& o) const override;
    std::shared_ptr<Object> __le__  (const Object& o) const override;
    std::shared_ptr<Object> __ge__  (const Object& o) const override;
};

# ```
# 

```./vm/obj/String.cpp
#include "String.hpp"
#include "Boolean.hpp"
#include "Integer.hpp"
#include <memory>

String::String(const std::string& v) : value(v) {}

std::string String::__str__() const {
    return value;
}

bool String::__bool__() const {
    return !value.empty();
}

std::string String::__name__() const {
    return "string";
}

std::shared_ptr<Object> String::__add__(const Object& o) const {
    return std::make_shared<String>(value + o.__str__());
}

std::shared_ptr<Object> String::__eq__(const Object& o) const {
    const auto* p = dynamic_cast<const String*>(&o);
    if (!p) return std::make_shared<Boolean>(false);
    return std::make_shared<Boolean>(value == p->value);
}
std::shared_ptr<Object> String::__mul__(const Object& o) const {
    const auto* p = dynamic_cast<const Integer*>(&o);
    if (!p) throw std::runtime_error("TypeError: string * " + o.__name__());
    std::string out;
    for (int i = 0; i < p->value; ++i) out += value;
    return std::make_shared<String>(out);
}

# ```
# 

```./vm/obj/Object.hpp
#pragma once
#include <string>

class Object : public std::enable_shared_from_this<Object> {
public:
    virtual std::string __str__()   const = 0;
    virtual bool        __bool__()  const { return true; }
    virtual int64_t     __int__()  const { return 0; }
    virtual double      __double__()  const { return 0; }

    // arithmetic & comparison
    virtual std::shared_ptr<Object> __add__ (const Object& o) const;
    virtual std::shared_ptr<Object> __sub__ (const Object& o) const;
    virtual std::shared_ptr<Object> __mul__ (const Object& o) const;
    virtual std::shared_ptr<Object> __div__ (const Object& o) const;
    virtual std::shared_ptr<Object> __mod__ (const Object& o) const;
    virtual std::shared_ptr<Object> __eq__  (const Object& o) const;
    virtual std::shared_ptr<Object> __lt__  (const Object& o) const;
    virtual std::shared_ptr<Object> __gt__  (const Object& o) const;
    virtual std::shared_ptr<Object> __le__  (const Object& o) const;
    virtual std::shared_ptr<Object> __ge__  (const Object& o) const;
    virtual std::shared_ptr<Object> __and__(const Object& o) const;
    virtual std::shared_ptr<Object> __or__ (const Object& o) const;
    virtual std::shared_ptr<Object> __not__() const;

    // iteration protocol
    virtual std::shared_ptr<Object> __iter__() const;
    virtual std::shared_ptr<Object> __next__();

    virtual std::string __name__() const = 0;
    virtual ~Object() = default;
};

# ```
# 

```./vm/obj/Scalar.hpp
#pragma once
#include "Object.hpp"

class Scalar : public Object {
public:
    virtual ~Scalar() = default;
};

# ```
# 

```./vm/obj/Undefined.hpp
#pragma once
#include "Object.hpp"

class Undefined : public Object {
public:
    Undefined();

    std::string __str__() const override;
    bool __bool__() const override;
    std::string __name__() const override;

    std::shared_ptr<Object> __add__ (const Object& o) const override;
    std::shared_ptr<Object> __eq__  (const Object& o) const override;
};

# ```
# 

```./vm/obj/Scientific.cpp
#include "Scientific.hpp"
#include "Decimal.hpp"
#include "Integer.hpp"
#include "Boolean.hpp"
#include <sstream>
#include <memory>

Scientific::Scientific(double v) : value(v) {}

std::string Scientific::__str__() const {
    std::ostringstream ss;
    ss.precision(10);
    ss << std::scientific << value;
    return ss.str();
}

bool Scientific::__bool__() const {
    return value != 0.0;
}

std::string Scientific::__name__() const {
    return "scientific";
}

std::shared_ptr<Object> Scientific::__add__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Scientific*>(&o)) {
        return std::make_shared<Scientific>(value + p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Scientific>(value + p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Scientific>(value + static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: scientific + " + o.__name__());
}

std::shared_ptr<Object> Scientific::__sub__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Scientific*>(&o)) {
        return std::make_shared<Scientific>(value - p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Scientific>(value - p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Scientific>(value - static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: scientific - " + o.__name__());
}

std::shared_ptr<Object> Scientific::__mul__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Scientific*>(&o)) {
        return std::make_shared<Scientific>(value * p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Scientific>(value * p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Scientific>(value * static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: scientific * " + o.__name__());
}

std::shared_ptr<Object> Scientific::__div__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Scientific*>(&o)) {
        if (p->value == 0.0) throw std::runtime_error("ZeroDivisionError");
        return std::make_shared<Scientific>(value / p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        if (p->value == 0.0) throw std::runtime_error("ZeroDivisionError");
        return std::make_shared<Scientific>(value / p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        if (p->value == 0) throw std::runtime_error("ZeroDivisionError");
        return std::make_shared<Scientific>(value / static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: scientific / " + o.__name__());
}

std::shared_ptr<Object> Scientific::__eq__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Scientific*>(&o)) {
        return std::make_shared<Boolean>(value == p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Boolean>(value == p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value == static_cast<double>(p->value));
    }
    return std::make_shared<Boolean>(false);
}

std::shared_ptr<Object> Scientific::__lt__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Scientific*>(&o)) {
        return std::make_shared<Boolean>(value < p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Boolean>(value < p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value < static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: scientific < " + o.__name__());
}

std::shared_ptr<Object> Scientific::__gt__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Scientific*>(&o)) {
        return std::make_shared<Boolean>(value > p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Boolean>(value > p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value > static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: scientific > " + o.__name__());
}

std::shared_ptr<Object> Scientific::__le__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Scientific*>(&o)) {
        return std::make_shared<Boolean>(value <= p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Boolean>(value <= p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value <= static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: scientific <= " + o.__name__());
}

std::shared_ptr<Object> Scientific::__ge__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Scientific*>(&o)) {
        return std::make_shared<Boolean>(value >= p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Boolean>(value >= p->value);
    }
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value >= static_cast<double>(p->value));
    }
    throw std::runtime_error("TypeError: scientific >= " + o.__name__());
}

# ```
# 

```./vm/obj/String.hpp
#pragma once
#include "Object.hpp"
#include <string>

class String : public Object {
public:
    std::string value;

    String(const std::string& v);

    std::string __str__() const override;
    bool __bool__() const override;
    std::string __name__() const override;

    std::shared_ptr<Object> __add__(const Object& o) const override;
    std::shared_ptr<Object> __mul__(const Object& o) const override;
    std::shared_ptr<Object> __eq__(const Object& o) const override;
};

# ```
# 

```./vm/obj/Integer.cpp
#include "Integer.hpp"
#include "Decimal.hpp"
#include "Boolean.hpp"
#include "String.hpp"
#include <memory>

Integer::Integer(int64_t v) : value(v) {}

std::string Integer::__str__() const {
    return std::to_string(value);
}

bool Integer::__bool__() const {
    return value != 0;
}

std::string Integer::__name__() const {
    return "integer";
}

std::shared_ptr<Object> Integer::__add__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Integer>(value + p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Decimal>(static_cast<double>(value) + p->value);
    }
    if (const auto* p = dynamic_cast<const String*>(&o)) {
        return std::make_shared<String>(__str__() + p->value);
    }
    throw std::runtime_error("TypeError: integer + " + o.__name__());
}

std::shared_ptr<Object> Integer::__sub__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Integer>(value - p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Decimal>(static_cast<double>(value) - p->value);
    }
    throw std::runtime_error("TypeError: integer - " + o.__name__());
}

std::shared_ptr<Object> Integer::__mul__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Integer>(value * p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Decimal>(static_cast<double>(value) * p->value);
    }
    throw std::runtime_error("TypeError: integer * " + o.__name__());
}

std::shared_ptr<Object> Integer::__div__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        if (p->value == 0) throw std::runtime_error("ZeroDivisionError: integer / integer");
        return std::make_shared<Integer>(value / p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        if (p->value == 0.0) throw std::runtime_error("ZeroDivisionError: integer / decimal");
        return std::make_shared<Decimal>(static_cast<double>(value) / p->value);
    }
    throw std::runtime_error("TypeError: integer / " + o.__name__());
}

std::shared_ptr<Object> Integer::__mod__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        if (p->value == 0) throw std::runtime_error("ZeroDivisionError: integer % integer");
        return std::make_shared<Integer>(value % p->value);
    }
    throw std::runtime_error("TypeError: integer % " + o.__name__());
}

std::shared_ptr<Object> Integer::__eq__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value == p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Boolean>(static_cast<double>(value) == p->value);
    }
    return std::make_shared<Boolean>(false);
}

std::shared_ptr<Object> Integer::__lt__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value < p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Boolean>(static_cast<double>(value) < p->value);
    }
    throw std::runtime_error("TypeError: integer < " + o.__name__());
}

std::shared_ptr<Object> Integer::__gt__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value > p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Boolean>(static_cast<double>(value) > p->value);
    }
    throw std::runtime_error("TypeError: integer > " + o.__name__());
}

std::shared_ptr<Object> Integer::__le__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value <= p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Boolean>(static_cast<double>(value) <= p->value);
    }
    throw std::runtime_error("TypeError: integer <= " + o.__name__());
}

std::shared_ptr<Object> Integer::__ge__(const Object& o) const {
    if (const auto* p = dynamic_cast<const Integer*>(&o)) {
        return std::make_shared<Boolean>(value >= p->value);
    }
    if (const auto* p = dynamic_cast<const Decimal*>(&o)) {
        return std::make_shared<Boolean>(static_cast<double>(value) >= p->value);
    }
    throw std::runtime_error("TypeError: integer >= " + o.__name__());
}
std::shared_ptr<Object> Integer::__or__(const Object& o) const {
    return std::make_shared<Boolean>(__bool__() || o.__bool__());
}
std::shared_ptr<Object> Integer::__and__(const Object& o) const {
    return std::make_shared<Boolean>(__bool__() && o.__bool__());
}
std::shared_ptr<Object> Integer::__not__() const {
    return std::make_shared<Boolean>(!__bool__());
}

# ```
# 

```./vm/obj/Boolean.cpp
#include "Boolean.hpp"
#include <string>
#include "Object.hpp"

Boolean::Boolean(bool v) : value(v) {}

std::string Boolean::__str__() const {
    return value ? "true" : "false";
}

bool Boolean::__bool__() const {
    return value;
}

std::string Boolean::__name__() const {
    return "boolean";
}

std::shared_ptr<Object> Boolean::__eq__(const Object& o) const {
    return std::make_shared<Boolean>(o.__bool__() == value);
}

std::shared_ptr<Object> Boolean::__and__(const Object& o) const {
    return std::make_shared<Boolean>(value && o.__bool__());
}

std::shared_ptr<Object> Boolean::__or__(const Object& o) const {
    return std::make_shared<Boolean>(value || o.__bool__());
}

std::shared_ptr<Object> Boolean::__not__() const {
    return std::make_shared<Boolean>(!value);
}

# ```
# 

```./vm/obj/Decimal.hpp
#pragma once
#include "Scalar.hpp"

class Decimal : public Scalar {
public:
    double value;
    Decimal(double v);

    std::string __str__() const override;
    bool __bool__() const override;
    std::string __name__() const override;

    std::shared_ptr<Object> __add__(const Object& o) const override;
    std::shared_ptr<Object> __sub__(const Object& o) const override;
    std::shared_ptr<Object> __mul__(const Object& o) const override;
    std::shared_ptr<Object> __div__(const Object& o) const override;

    std::shared_ptr<Object> __eq__ (const Object& o) const override;
    std::shared_ptr<Object> __lt__ (const Object& o) const override;
    std::shared_ptr<Object> __gt__ (const Object& o) const override;
    std::shared_ptr<Object> __le__ (const Object& o) const override;
    std::shared_ptr<Object> __ge__ (const Object& o) const override;
    std::shared_ptr<Object> __and__(const Object& o) const override;
    std::shared_ptr<Object> __or__ (const Object& o) const override;
    std::shared_ptr<Object> __not__() const override;
};

# ```
# 

```./vm/obj/RegEx.cpp
#include "RegEx.hpp"

RegEx::RegEx(const std::string& pattern, const std::set<char>& f)
    : String(pattern), flags(f) {}

std::string RegEx::__name__() const {
    return "string::regex";
}

bool RegEx::has_flag(char flag) const {
    return flags.find(flag) != flags.end();
}

# ```
# 

```./vm/core/Memory.cpp
#include "Memory.hpp"
#include "string"
#include "../obj/Undefined.hpp"

void Memory::declare(const std::string& n) {
    if (mem.find(n) != mem.end())
        throw std::runtime_error("Already declared: " + n);
    mem[n] = std::make_shared<Undefined>();
}
void Memory::set(const std::string& n, const std::shared_ptr<Object>& v) {
    mem[n] = v;
}
void Memory::remove(const std::string& n) {
    auto it = mem.find(n);
    if (it == mem.end())
        throw std::runtime_error("Cannot erase undeclared variable: " + n);
    mem.erase(it);
}
const std::shared_ptr<Object>& Memory::get(const std::string& n) const {
    auto it = mem.find(n);
    if (it == mem.end())
        throw std::runtime_error("Undefined var: " + n);
    return it->second;
}
bool Memory::has(const std::string& n) const {
    auto it = mem.find(n);
    return it != mem.end();
}

# ```
# 

```./vm/core/opmap.hpp
#pragma once
#include <unordered_map>
#include <string>
#include "Opcode.hpp"

extern const std::unordered_map<std::string, Opcode> opmap;

extern const Opcode get_opcode_from_string(const std::string& opcode);
extern const std::string get_string_from_opcode(Opcode opcode);

# ```
# 

```./vm/core/Bytecode.cpp
#include "Bytecode.hpp"
#include "opmap.hpp"

std::string Bytecode::toString() {
    std::string opname = "UNDEFINED_OP_CODE";
    for (auto kv : opmap) {
        if (kv.second == opcode) {
            opname = kv.first;
        }
    }

    std::string out = "(" + opname + ",";
    for (auto o : operand) {
        out += o + ",";
    }

    return out.substr(0, out.size() - 1) + ")";
}

# ```
# 

```./vm/core/Process.cpp
#include <iostream>
#include "Process.hpp"
#include "Bytecode.hpp"
#include "../exec/exec.hpp"
#include "../helpers/exec_step.hpp"

void Process::execute() {
    // Collect all labels
    for (size_t c = 0; c < module.size(); ++c) {
        const Bytecode& b = module[c];
        if (b.opcode == OP_LABEL) {
            const std::string& name = b.operand.at(0);

            // Skip label if invalid
            if (name.empty()) {
                std::cerr << "Invalid label at index " << c << std::endl;
                exit(3);
            }

            // Register the label  next instruction
            labels.set(name, c + 1);
        }
    }

    if (!labels.exists("main")) {
        err("Expected .main label. None found.");
        return;
    }

    pc = labels.get("main");
    while (!completed && !broken) {
        exec_step(*this);
    }
}

void Process::err(const std::string& message, const int& code) {
    std::cerr << "An error occured during the bytecode execution." << std::endl << "\tDuring process count: " << pc << std::endl << "Error: " << message << std::endl;
    completed = true;
    broken = true;
}

void Process::err(const std::string& message) {
    err(message, -1);
}

# ```
# 

```./vm/core/SectionTable.hpp
#pragma once
#include <unordered_map>
#include <string>

struct SectionTable {
    std::unordered_map<std::string, size_t> sections;
};

# ```
# 

```./vm/core/EnvStack.hpp
#pragma once
#include <vector>
#include <memory>
#include <string>
#include "../../vm/core/Memory.hpp"
#include "../../vm/obj/Object.hpp"

/**
 * EnvStack manages a stack of Memory scopes
 * for local variable environments (e.g., inside functions).
 */
class EnvStack {
public:
    EnvStack();

    // Scope management
    void push_scope();
    void pop_scope();

    // Variable operations
    void declare(const std::string& name);
    bool set(const std::string& name, const std::shared_ptr<Object>& value);
    std::shared_ptr<Object> get(const std::string& name) const;
    bool has(const std::string& name) const;
    bool set_or_declare(const std::string& name,
                        const std::shared_ptr<Object>& value);

    // Utility
    bool empty() const;
    size_t size() const;

private:
    std::vector<Memory> scopes;
};

# ```
# 

```./vm/core/OperandStack.cpp
#include "OperandStack.hpp"

void OperandStack::push(const std::shared_ptr<Object>& v) {
    nodes.push_back(v);
}
std::shared_ptr<Object> OperandStack::pop() {
    if (nodes.empty()) throw std::runtime_error("OperandStack underflow");
    auto v = nodes.back();
    nodes.pop_back();
    return v;
}
bool OperandStack::empty() const {
    return nodes.empty();
}
size_t OperandStack::size() const {
    return nodes.size();
}
std::shared_ptr<Object> OperandStack::back() const {
    return nodes.back();
}

# ```
# 

```./vm/core/CallStack.hpp
#pragma once
#include <vector>

struct CallStack {
    std::vector<size_t> stack;
    void push(const size_t);
    size_t pop();
    bool   empty() const;
    size_t size() const;
    size_t back() const;
};

# ```
# 

```./vm/core/LabelMap.cpp
#include "LabelMap.hpp"

void LabelMap::set(std::string label, size_t pc) {
    labels[label] = pc;
}

size_t LabelMap::get(std::string label) {
    return labels[label];
}

bool LabelMap::exists(std::string label) {
    return labels.contains(label);
}

# ```
# 

```./vm/core/Opcode.hpp
#pragma once

enum Opcode {
    OP_PUSH = 0,
    OP_POP, OP_DUP, OP_SWAP, OP_DEL,
    OP_DECL, OP_SET, OP_GET,
    OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MOD,
    OP_EQ, OP_LT, OP_GT, OP_AND, OP_OR, OP_NOT,
    OP_JMP, OP_JZ, OP_JNZ,
    OP_LABEL, OP_CALL, OP_RET, OP_END,
    OP_WRITE, OP_FLUSH, OP_DUMP,
    OP_IN, OP_FREAD, OP_FWRITE, OP_EXIT,
    OP_RAND, OP_TIME, OP_SLEEP, OP_CAST,
    OP_TYPE, NOP, OP_CONST_PI, OP_CONST_E,
};

# ```
# 

```./vm/core/TypeTable.hpp
#include <string>
#include <unordered_map>
struct TypeTable {
    std::unordered_map<std::string, std::string> types;
    void set(const std::string& name, const std::string& type);
    std::string get(const std::string& name) const;
    bool has(const std::string& name) const;
};

# ```
# 

```./vm/core/Buffer.cpp
#include <string>
#include <iostream>
#include "Buffer.hpp"

void Buffer::write(const std::string& s) {
    out << s;
}
void Buffer::dump() const {
    std::cout << out.str();
}
void Buffer::flush() {
    out.str("");
    out.clear();
    std::cout << std::flush;
}

# ```
# 

```./vm/core/OperandStack.hpp
#pragma once
#include <vector>
#include "../obj/Object.hpp"

struct OperandStack {
    std::vector<std::shared_ptr<Object>> nodes;
    void push(const std::shared_ptr<Object>&);
    std::shared_ptr<Object> pop();
    bool empty() const;
    size_t size()  const;
    std::shared_ptr<Object> back() const;
};

# ```
# 

```./vm/core/CallStack.cpp
#include "CallStack.hpp"

void CallStack::push(const size_t v) {
    stack.push_back(v);
}
size_t CallStack::pop() {
    if (stack.empty()) throw std::runtime_error("CallStack underflow");
    auto v = stack.back();
    stack.pop_back();
    return v;
}
bool CallStack::empty() const {
    return stack.empty();
}
size_t CallStack::size() const {
    return stack.size();
}
size_t CallStack::back() const {
    return stack.back();
}

# ```
# 

```./vm/core/LabelMap.hpp
#include <unordered_map>
#include <string>

struct LabelMap {
    std::unordered_map<std::string, size_t> labels = {};
    void set(std::string label, size_t pc);

    size_t get(std::string label);

    bool exists(std::string label);
};

# ```
# 

```./vm/core/TypeTable.cpp
#include "TypeTable.hpp"
std::unordered_map<std::string, std::string> types;

void TypeTable::set(const std::string& name, const std::string& type) {
    types[name] = type;
}

std::string TypeTable::get(const std::string& name) const {
    auto it = types.find(name);
    if (it == types.end()) return "any";
    return it->second;
}

bool TypeTable::has(const std::string& name) const {
    return types.find(name) != types.end();
}

# ```
# 

```./vm/core/Buffer.hpp
#pragma once
#include <string>
#include <sstream>

struct Buffer {
    std::ostringstream out;
    void write (const std::string&);
    void dump  () const;
    void flush ();
};

# ```
# 

```./vm/core/Memory.hpp
#pragma once
#include <unordered_map>
#include "../obj/Object.hpp"

struct Memory {
    std::unordered_map<std::string, std::shared_ptr<Object>> mem;
    void declare(const std::string&);
    void set    (const std::string&, const std::shared_ptr<Object>&);
    void remove (const std::string&);
    bool has    (const std::string&) const;
    const std::shared_ptr<Object>& get(const std::string&) const;
};

# ```
# 

```./vm/core/opmap.cpp
#include "opmap.hpp"
#include <stdexcept>

const std::unordered_map<std::string, Opcode> opmap = {
    {"PUSH", OP_PUSH}, {"POP", OP_POP}, {"DUP", OP_DUP}, {"SWAP", OP_SWAP},
    {"DEL", OP_DEL}, {"DECL", OP_DECL}, {"SET", OP_SET}, {"GET", OP_GET},
    {"ADD", OP_ADD}, {"SUB", OP_SUB}, {"MUL", OP_MUL}, {"DIV", OP_DIV},
    {"MOD", OP_MOD}, {"EQ", OP_EQ}, {"LT", OP_LT}, {"GT", OP_GT},
    {"AND", OP_AND}, {"OR", OP_OR}, {"NOT", OP_NOT}, {"JMP", OP_JMP},
    {"JZ", OP_JZ}, {"JNZ", OP_JNZ}, {"CALL", OP_CALL}, {"RET", OP_RET},
    {"END", OP_END}, {"WRITE", OP_WRITE}, {"FLUSH", OP_FLUSH}, {"DUMP", OP_DUMP},
    {"IN", OP_IN}, {"FREAD", OP_FREAD}, {"FWRITE", OP_FWRITE}, {"EXIT", OP_EXIT},
    {"RAND", OP_RAND}, {"TIME", OP_TIME}, {"SLEEP", OP_SLEEP}, {"NOP", NOP},
    {"TYPE", OP_TYPE}, {"CAST", OP_CAST}, {"LABEL", OP_LABEL}
};


// Define reverse mappings from Opcode  string
const std::unordered_map<Opcode, std::string> strmap = [] {
    std::unordered_map<Opcode, std::string> rev;
    for (const auto& [key, val] : opmap) {
        rev[val] = key;
    }
    return rev;
}();

// Lookup function: string  Opcode
const Opcode get_opcode_from_string(const std::string& opcode) {
    auto it = opmap.find(opcode);
    if (it != opmap.end())
        return it->second;
    throw std::invalid_argument("Unknown opcode: " + opcode);
}

// Lookup function: Opcode  string
const std::string get_string_from_opcode(Opcode opcode) {
    auto it = strmap.find(opcode);
    if (it != strmap.end())
        return it->second;
    return "UNKNOWN";
}

# ```
# 

```./vm/core/Bytecode.hpp
#pragma once
#include <string>
#include <vector>
#include "Opcode.hpp"

struct Bytecode {
    Opcode opcode;
    std::vector<std::string> operand;
    Bytecode(Opcode op, std::vector<std::string> o = {}) : opcode(op), operand(std::move(o)) {}
    std::string toString();
};

# ```
# 

```./vm/core/Process.hpp
#pragma once
#include <iostream>
#include <string>
#include <vector>
#include "Buffer.hpp"
#include "Bytecode.hpp"
#include "OperandStack.hpp"
#include "SectionTable.hpp"
#include "LabelMap.hpp"
#include "Memory.hpp"
#include "CallStack.hpp"
#include "EnvStack.hpp"

struct Process {
    std::vector<Bytecode>     module               ;
    Buffer                    buffer               ;
    OperandStack              stack                ;
    SectionTable              sections             ;
    LabelMap                  labels               ;
    Memory                    global_memory        ;
    size_t                    pc            = 0    ;
    EnvStack                  env_stack            ;
    CallStack                 callstack            ;
    bool                      completed     = false;
    bool                      broken        = false;

    Process(std::vector<Bytecode> m) : module(std::move(m)) {
        env_stack.push_scope();      //  global-scope frame
    };

    /**
     * Begins the process
     */
    void execute();

    void err(const std::string& message, const int& code);
    void err(const std::string& message);
};

# ```
# 

```./vm/core/EnvStack.cpp
#include "EnvStack.hpp"
#include <stdexcept>

// --- Constructor ---
EnvStack::EnvStack() = default;

// --- Scope management ---
void EnvStack::push_scope() {
    scopes.emplace_back();
}

void EnvStack::pop_scope() {
    if (scopes.empty()) {
        throw std::runtime_error("EnvStack: Cannot pop from an empty scope stack.");
    }
    scopes.pop_back();
}

// --- Variable operations ---
void EnvStack::declare(const std::string& name) {
    if (scopes.empty()) {
        throw std::runtime_error("EnvStack: No local scope to declare variable '" + name + "'.");
    }
    scopes.back().declare(name);
}

bool EnvStack::set(const std::string& name, const std::shared_ptr<Object>& value) {
    for (auto it = scopes.rbegin(); it != scopes.rend(); ++it) {
        if (it->has(name)) {
            it->set(name, value);
            return true;
        }
    }
    return false; // Not found in any local scope
}

std::shared_ptr<Object> EnvStack::get(const std::string& name) const {
    for (auto it = scopes.rbegin(); it != scopes.rend(); ++it) {
        if (it->has(name)) {
            return it->get(name);
        }
    }
    throw std::runtime_error("EnvStack: Undefined variable '" + name + "'.");
}

bool EnvStack::has(const std::string& name) const {
    for (auto it = scopes.rbegin(); it != scopes.rend(); ++it) {
        if (it->has(name)) {
            return true;
        }
    }
    return false;
}


bool EnvStack::set_or_declare(const std::string& n,
                              const std::shared_ptr<Object>& v) {
    if (set(n, v)) return true;
    if (!scopes.empty()) { scopes.back().declare(n); scopes.back().set(n,v); }
    return true;
}

// --- Utility ---
bool EnvStack::empty() const {
    return scopes.empty();
}

size_t EnvStack::size() const {
    return scopes.size();
}

# ```
# 

```./vm/exec/RET.cpp
#include "exec.hpp"
#include "RET.hpp"
bool exec::RET(Process& p) {
     if (p.callstack.empty()) {
        p.err("Return without call");
        return false;
     }

     if (p.stack.empty()) {
        p.err("Attempted to return from empty stack");
        return false;
     }

     p.env_stack.pop_scope();    // drop callees locals
     p.pc = p.callstack.pop();
     return true;
 }

# ```
# 

```./vm/exec/CAST.hpp
#pragma once
#include "exec.hpp"
bool exec::CAST(Process& p);

# ```
# 

```./vm/exec/WRITE.cpp
#include "WRITE.hpp"
#include "exec.hpp"
bool exec::WRITE(Process& p) {
    p.buffer.write(p.stack.pop()->__str__());
    return true;
}

# ```
# 

```./vm/exec/JNZ.hpp
#pragma once
#include "exec.hpp"
bool exec::JNZ(Process& p);

# ```
# 

```./vm/exec/BINARY_OP.hpp
#pragma once
#include "../core/Process.hpp"

namespace exec {
    bool ADD(Process& p);
    bool SUB(Process& p);
    bool MUL(Process& p);
    bool DIV(Process& p);
    bool MOD(Process& p);
    bool EQ(Process& p);
    bool GT(Process& p);
    bool LT(Process& p);
    bool OR(Process& p);
    bool AND(Process& p);
}

# ```
# 

```./vm/exec/GET.hpp
#pragma once
#include "exec.hpp"
bool exec::GET(Process& p);

# ```
# 

```./vm/exec/DUP.cpp
#include "DUP.hpp"
#include "exec.hpp"
bool exec::DUP(Process& p)  {
    if (p.stack.empty()) return true;
    p.stack.push(p.stack.back());
    return true;
}

# ```
# 

```./vm/exec/DUMP.hpp
#pragma once
#include "exec.hpp"
bool exec::DUMP(Process& p);

# ```
# 

```./vm/exec/JMP.hpp
#pragma once
#include "exec.hpp"
bool exec::JMP(Process& p);

# ```
# 

```./vm/exec/TYPE.hpp
#pragma once
#include <string>
#include "exec.hpp"
#include "../helpers/is_valid_identifier.hpp"
bool exec::TYPE(Process& p);

# ```
# 

```./vm/exec/TIME.hpp
#pragma once
#include "exec.hpp"
bool exec::TIME(Process& p);

# ```
# 

```./vm/exec/DEL.cpp
#include "DEL.hpp"
#include "exec.hpp"
bool exec::DEL(Process& p) {
    const auto& b = p.module[p.pc];
    if (p.env_stack.has(b.operand.at(0)))
        p.env_stack.pop_scope();            // optional: or implement remove()
    else
        p.global_memory.remove(b.operand.at(0));
    return true;
}

# ```
# 

```./vm/exec/LABEL.hpp
#pragma once
#include "exec.hpp"
bool exec::LABEL(Process& p);

# ```
# 

```./vm/exec/RAND.hpp
#pragma once
#include "exec.hpp"
bool exec::RAND(Process& p);

# ```
# 

```./vm/exec/SWAP.cpp
#include "SWAP.hpp"
#include "exec.hpp"
bool exec::SWAP(Process& p) {
    if (p.stack.size() < 2) return true;
    auto a = p.stack.pop();
    auto b = p.stack.pop();
    p.stack.push(a);
    p.stack.push(b);
    return true;
}

# ```
# 

```./vm/exec/SET.cpp
#include "SET.hpp"
#include "exec.hpp"

bool exec::SET(Process& p) {
    const auto& b = p.module[p.pc];

    if (b.operand.empty()) {
        p.err("Missing operand in SET");
        return false;
    }

    const std::string& name = b.operand.at(0);

    if (p.stack.empty()) {
        p.err("SET failed: stack is empty");
        return false;
    }

    std::shared_ptr<Object> val = p.stack.back();

    // Try setting in env_stack first
    if (!p.env_stack.set(name, val)) {
        // If it doesn't exist in env_stack, set in global memory
        p.global_memory.set(name, val);
    }

    p.stack.pop();
    return true;
}

# ```
# 

```./vm/exec/EXIT.cpp
#include "EXIT.hpp"
#include "exec.hpp"
bool exec::EXIT(Process& p)  {
    p.completed = true;
    return true;
}

# ```
# 

```./vm/exec/CALL.cpp
#include <string>
#include "CALL.hpp"
#include "exec.hpp"
bool exec::CALL(Process& p)  {
    p.env_stack.push_scope();
    const auto& b = p.module[p.pc];

    // ensure a label is passed
    if (b.operand.size() != 1) {
        p.err("Recieved a bytecode: (CALL) but expected exactly two nodes: (CALL, .<label_name>)");
        return false;
    }

    // extract label name
    const std::string& nm = b.operand.at(0); // label name

    // ensure is valid label name
    if (!p.labels.exists(nm)) {
        p.err("Unknown function label in (CALL): '" + nm + "'");
        return false;
    }
    p.pc = p.labels.get(nm);

    p.callstack.push(p.pc + 1);
    p.pc = p.labels.get(nm.substr(1));
    return true;
}

# ```
# 

```./vm/exec/PUSH.cpp
#include "PUSH.hpp"
#include "../helpers/parse_literal.hpp"
#include "exec.hpp"
bool exec::PUSH(Process& p) {
    const auto& b = p.module[p.pc];
    p.stack.push(parse_literal(b.operand.at(0)));
    return true;
}

# ```
# 

```./vm/exec/POP.cpp
#include "POP.hpp"
#include "exec.hpp"

bool exec::POP(Process& p) {
    const auto& b = p.module[p.pc];
    if (p.stack.empty()) {
        p.err("Attempted to pop from an empty stack");
        return false;
    }

    auto value = p.stack.pop();
    if (!p.env_stack.set(b.operand.at(0), value)) {
        p.global_memory.set(b.operand.at(0), value);
    }
    return true;
}

# ```
# 

```./vm/exec/UNARY_OP.hpp
#pragma once
#include "../core/Process.hpp"

namespace exec {
    bool NOT(Process& p);
}

# ```
# 

```./vm/exec/FLUSH.cpp
#include "FLUSH.hpp"
#include "exec.hpp"
bool exec::FLUSH(Process& p) {
    p.buffer.flush();
    return true;
}

# ```
# 

```./vm/exec/JZ.cpp
#include <string>
#include "JZ.hpp"
#include "exec.hpp"
bool exec::JZ(Process& p) {
    auto cond = p.stack.pop();
    const auto& b = p.module[p.pc];
    std::string nm = b.operand.at(0);
    if (cond->__bool__()) {
        if (nm.size() >= 2 && nm[0]=='.' && p.labels.exists(nm.substr(1)))
            p.pc = p.labels.get(nm.substr(1));
        else return false;
    }
    return true;
}

# ```
# 

```./vm/exec/DECL.cpp
#include "DECL.hpp"
#include "exec.hpp"
bool exec::DECL(Process& p) {
    const auto& b = p.module[p.pc];
    if (!p.env_stack.empty())
        p.env_stack.declare(b.operand.at(0));
    else
        p.global_memory.declare(b.operand.at(0));
    return true;
}

# ```
# 

```./vm/exec/DEL.hpp
#pragma once
#include "exec.hpp"
bool exec::DEL(Process& p);

# ```
# 

```./vm/exec/LABEL.cpp
#include <string>
#include "LABEL.hpp"
#include "exec.hpp"
#include "../helpers/is_valid_identifier.hpp"

// New helper for namespaced label validation
bool is_valid_namespaced_identifier(const std::string& name) {
    // Split by '.'
    size_t start = 0;
    while (start < name.size()) {
        size_t dot = name.find('.', start);
        std::string part = name.substr(start, dot - start);
        if (!is_valid_identifier(part))
            return false;
        if (dot == std::string::npos)
            break;
        start = dot + 1;
    }
    return true;
}

bool exec::LABEL(Process& p) {
    const auto& b = p.module[p.pc];
    std::string name = b.operand.at(0);

    // No longer require leading '.', but ensure name is valid
    if (!is_valid_namespaced_identifier(name)) {
        p.err("Invalid label name: " + name);
        return false;
    }

    // Store label exactly as-is (e.g., "Math.Linear.dot")
    p.labels.set(name, p.pc + 1);
    return true;
}

# ```
# 

```./vm/exec/RAND.cpp
#include <random>
#include "../obj/Decimal.hpp"
#include "RAND.hpp"
#include "exec.hpp"
bool exec::RAND(Process& p) {
    static std::mt19937 rng{std::random_device{}()};
    std::uniform_real_distribution<double> dist(0.0,1.0);
    p.stack.push(std::make_shared<Decimal>(dist(rng)));
    return true;
}

# ```
# 

```./vm/exec/SWAP.hpp
#pragma once
#include "exec.hpp"
bool exec::SWAP(Process& p);

# ```
# 

```./vm/exec/SET.hpp
#pragma once
#include "exec.hpp"
bool exec::SET(Process& p);

# ```
# 

```./vm/exec/EXIT.hpp
#pragma once
#include "exec.hpp"
bool exec::EXIT(Process& p);

# ```
# 

```./vm/exec/CALL.hpp
#pragma once
#include "exec.hpp"
bool exec::CALL(Process& p);

# ```
# 

```./vm/exec/POP.hpp
#pragma once
#include "exec.hpp"
bool exec::POP(Process& p);

# ```
# 

```./vm/exec/PUSH.hpp
#pragma once
#include "exec.hpp"
bool exec::PUSH(Process& p);

# ```
# 

```./vm/exec/UNARY_OP.cpp
#include "UNARY_OP.hpp"
#include <stdexcept>

#define UNARY_OP(name, method)                     \
bool exec::name(Process& p) {                      \
    if (p.stack.empty())                           \
        throw std::runtime_error(#name " underflow"); \
    auto val = p.stack.pop();                      \
    p.stack.push(val->method());                   \
    return true;                                   \
}

UNARY_OP(NOT, __not__)

# ```
# 

```./vm/exec/exec.hpp
#pragma once
#include "../core/Process.hpp"

namespace exec {
    // VM opcode handlers
    bool LABEL(Process&);
    bool PUSH(Process&);
    bool POP(Process&);
    bool DUP(Process&);
    bool DECL(Process&);
    bool TYPE(Process&);
    bool CAST(Process&);
    bool SWAP(Process&);
    bool SET(Process&);
    bool GET(Process&);
    bool DEL(Process&);
    bool WRITE(Process&);
    bool FLUSH(Process&);
    bool DUMP(Process&);
    bool ADD(Process&);
    bool SUB(Process&);
    bool MUL(Process&);
    bool DIV(Process&);
    bool MOD(Process&);
    bool EQ(Process&);
    bool GT(Process&);
    bool LT(Process&);
    bool OR(Process&);
    bool AND(Process&);
    bool NOT(Process&);
    bool JMP(Process&);
    bool JNZ(Process&);
    bool JZ(Process&);
    bool EXIT(Process&);
    bool RET(Process&);
    bool CALL(Process&);
    bool RAND(Process&);
    bool TIME(Process&);
}

# ```
# 

```./vm/exec/FLUSH.hpp
#pragma once
#include "exec.hpp"
bool exec::FLUSH(Process& p);

# ```
# 

```./vm/exec/DECL.hpp
#pragma once
#include "exec.hpp"
bool exec::DECL(Process& p);

# ```
# 

```./vm/exec/JZ.hpp
#pragma once
#include "exec.hpp"
bool exec::JZ(Process& p);

# ```
# 

```./vm/exec/WRITE.hpp
#pragma once
#include "exec.hpp"
bool exec::WRITE(Process& p);

# ```
# 

```./vm/exec/CAST.cpp
#include "CAST.hpp"
bool exec::CAST(Process &p) {
    return true;
}

# ```
# 

```./vm/exec/RET.hpp
#pragma once
#include "exec.hpp"
bool exec::RET(Process& p);

# ```
# 

```./vm/exec/JNZ.cpp
#include <string>
#include "JNZ.hpp"
#include "exec.hpp"
bool exec::JNZ(Process& p) {
    auto cond = p.stack.pop();
    const auto& b = p.module[p.pc];
    std::string nm = b.operand.at(0);
    if (!cond->__bool__()) {
        if (nm.size() >= 2 && nm[0]=='.' && p.labels.exists(nm.substr(1)))
            p.pc = p.labels.get(nm.substr(1));
        else return false;
    }
    return true;
}

# ```
# 

```./vm/exec/BINARY_OP.cpp
#include "BINARY_OP.hpp"
#include <stdexcept>

// Define macro locally to this translation unit
#define BINARY_OP(name, method)                     \
bool exec::name(Process& p) {                       \
    if (p.stack.size() < 2)                         \
        throw std::runtime_error(#name " underflow"); \
    auto rhs = p.stack.pop();                       \
    auto lhs = p.stack.pop();                       \
    p.stack.push(lhs->method(*rhs));                \
    return true;                                    \
}

BINARY_OP(ADD,   __add__)
BINARY_OP(SUB,   __sub__)
BINARY_OP(MUL,   __mul__)
BINARY_OP(DIV,   __div__)
BINARY_OP(MOD,   __mod__)
BINARY_OP(EQ,    __eq__)
BINARY_OP(GT,    __gt__)
BINARY_OP(LT,    __lt__)
BINARY_OP(OR,    __or__)
BINARY_OP(AND,    __and__)
#undef BINARY_OP

# ```
# 

```./vm/exec/GET.cpp
#include "GET.hpp"
#include "../helpers/parse_literal.hpp"
#include "exec.hpp"

bool exec::GET(Process& p) {
    const auto& b = p.module[p.pc];

    if (b.operand.empty()) {
        p.err("Missing operand in GET");
        return false;
    }

    const std::string& name = b.operand.at(0);
    std::shared_ptr<Object> val;

    if (p.env_stack.has(name)) {
        val = p.env_stack.get(name);
    } else if (p.global_memory.has(name)) {
        val = p.global_memory.get(name);
    } else {
        p.err("GET failed: variable not found  " + name);
        return false;
    }

    p.stack.push(val);
    return true;
}

# ```
# 

```./vm/exec/DUP.hpp
#pragma once
#include "exec.hpp"
bool exec::DUP(Process& p);

# ```
# 

```./vm/exec/DUMP.cpp
#include "DUMP.hpp"
#include "exec.hpp"
bool exec::DUMP(Process& p) {
    p.buffer.dump();
    return true;
}

# ```
# 

```./vm/exec/JMP.cpp
#include <string>
#include "JMP.hpp"
#include "exec.hpp"

bool exec::JMP(Process& p) {
    const auto& b = p.module[p.pc];

    // Ensure operand exists
    if (b.operand.empty()) {
        p.err("Missing operand in JMP instruction");
        return false;
    }

    std::string nm = b.operand.at(0);

    // Try to jump to label as-is
    if (!p.labels.exists(nm)) {
        p.err("Unknown label in JMP: '" + nm + "'");
        return false;
    }

    // Perform the jump
    p.pc = p.labels.get(nm);
    return true;
}

# ```
# 

```./vm/exec/TYPE.cpp
#include "TYPE.hpp"
bool exec::TYPE(Process& p) {
    Bytecode b = p.module.at(p.pc);
    if (b.operand.size() != 2) return false;

    auto& o1 = b.operand.at(0);
    auto& o2 = b.operand.at(1);

    if (
        o1.size() < 2 ||
        o1.at(0) != '$' ||
        !is_valid_identifier(o1.substr(1))
    ) return true;

    std::string iden = o1;
    std::string type = o2;

    return true;
}

# ```
# 

```./vm/exec/TIME.cpp
#include "../helpers/get_nanotime.hpp"
#include "../obj/Integer.hpp"
#include "exec.hpp"
bool exec::TIME(Process& p) {
    p.stack.push(std::make_shared<Integer>(get_nanotime()));
    return true;
}

# ```
# 

```./vm/helpers/parse_literal.hpp
#pragma once
#include <string>
#include <cctype>
#include <set>
#include <stdexcept>
#include <memory>
#include "../obj/Object.hpp"
#include "../obj/Boolean.hpp"
#include "../obj/String.hpp"
#include "../obj/Integer.hpp"
#include "../obj/Decimal.hpp"
#include "../obj/Scientific.hpp"
#include "../obj/RegEx.hpp"
#include "../helpers/str_decode.hpp"

std::shared_ptr<Object> parse_literal(const std::string& tok);

# ```
# 

```./vm/helpers/str_encode.cpp
#include <string>

/**
 * Encodes a string into a literal form, escaping special characters
 * e.g. str_encode("hello\nworld") becomes "hello\\nworld"
 */
void str_encode(std::string& str) {
    std::string result;
    result.reserve(str.size() + 10); // reserve slightly more to avoid reallocations

    for (char ch : str) {
        switch (ch) {
            case '\n': result += "\\n"; break;
            case '\r': result += "\\r"; break;
            case '\t': result += "\\t"; break;
            case '\\': result += "\\\\"; break;
            case '"':  result += "\\\""; break;
            case '\'': result += "\\\'"; break;
            case '\0': result += "\\0"; break;
            default:
                // Only encode visible ASCII (printable characters)
                result += ch;
                break;
        }
    }

    str = std::move('"' + result + '"');
}

# ```
# 

```./vm/helpers/get_nanotime.hpp
#pragma once
#include <chrono>

int64_t get_nanotime();

# ```
# 

```./vm/helpers/split.cpp
#include <string>
#include <vector>
#include <sstream>
#include "split.hpp"
#include "trim.hpp"

std::vector<std::string> split(const std::string &s, char d)  {
    std::vector<std::string> out;
    std::istringstream ss(s);
    std::string item;
    while (std::getline(ss, item, d))
        if (!trim(item).empty())
            out.push_back(trim(item));
    return out;
}

# ```
# 

```./vm/helpers/unordered_map_to_string.cpp
#include "unordered_map_to_string.hpp"

template <typename K, typename V>
std::string unordered_map_to_string(const std::unordered_map<K, V>& umap) {
    std::stringstream ss;
    ss << "{";
    for (const auto& pair : umap) {
        ss << "\"" << pair.first << "\":\"" << pair.second << "\",";
    }

    std::string result = ss.str();
    if (result.length() > 1) {
        result.pop_back(); // Remove the trailing comma
    }
    result += "}";
    return result;
}

# ```
# 

```./vm/helpers/exec_step.cpp
#include <iomanip>
#include <iostream>
#include "../helpers/exec_step.hpp"
#include "../core/Process.hpp"
#include "../core/opmap.hpp"
#include "../core/Bytecode.hpp"
#include "../exec/exec.hpp"

void exec_step(Process& p) {
    Bytecode& instr = p.module.at(p.pc);
    bool ok = false;
    size_t before = p.pc;
    // std::cout << "Executing process id: '" << std::setw(5) << std::setfill('0') << p.pc << "'; bytecode: '" + instr.toString() + "'" << std::endl;
    switch (instr.opcode) {
        case OP_PUSH:  ok = exec::PUSH  (p);    break;
        case OP_POP:   ok = exec::POP   (p);    break;
        case OP_DUP:   ok = exec::DUP   (p);    break;
        case OP_DECL:  ok = exec::DECL  (p);    break;
        case OP_SWAP:  ok = exec::SWAP  (p);    break;
        case OP_SET:   ok = exec::SET   (p);    break;
        case OP_GET:   ok = exec::GET   (p);    break;
        case OP_DEL:   ok = exec::DEL   (p);    break;
        case OP_WRITE: ok = exec::WRITE (p);    break;
        case OP_FLUSH: ok = exec::FLUSH (p);    break;
        case OP_DUMP:  ok = exec::DUMP  (p);    break;
        case OP_ADD:   ok = exec::ADD   (p);    break;
        case OP_SUB:   ok = exec::SUB   (p);    break;
        case OP_MUL:   ok = exec::MUL   (p);    break;
        case OP_DIV:   ok = exec::DIV   (p);    break;
        case OP_MOD:   ok = exec::MOD   (p);    break;
        case OP_EQ:    ok = exec::EQ    (p);    break;
        case OP_GT:    ok = exec::GT    (p);    break;
        case OP_LT:    ok = exec::LT    (p);    break;
        case OP_AND:   ok = exec::AND   (p);    break;
        case OP_OR:    ok = exec::OR    (p);    break;
        case OP_NOT:   ok = exec::NOT   (p);    break;
        case OP_JMP:   ok = exec::JMP   (p);    break;
        case OP_JNZ:   ok = exec::JNZ   (p);    break;
        case OP_JZ:    ok = exec::JZ    (p);    break;
        case OP_EXIT:  ok = exec::EXIT  (p);    break;
        case OP_RET:   ok = exec::RET   (p);    break;
        case OP_CALL:  ok = exec::CALL  (p);    break;
        case OP_RAND:  ok = exec::RAND  (p);    break;
        case OP_TIME:  ok = exec::TIME  (p);    break;
        case NOP:                               break;
        case OP_LABEL: ok = true;               break;
        case OP_TYPE:  ok = exec::TYPE  (p);    break;
        case OP_CAST:  ok = exec::CAST  (p);    break;
        case OP_IN:
        case OP_SLEEP:
        case OP_FREAD:
        case OP_FWRITE:
        case OP_END:                            break;
        default:
            throw std::runtime_error("Opcode not implemented");
    }
    if (!ok) {
        p.broken = true;
        p.err("Exited with an error from " + get_string_from_opcode(instr.opcode));
    }

    if (p.pc == before && !p.completed && !p.broken) {
        p.pc++;
    }
}

# ```
# 

```./vm/helpers/trim.hpp
#pragma once
#include <string>

std::string trim(const std::string &s);

# ```
# 

```./vm/helpers/str_decode.cpp
#include "str_decode.hpp"

void str_decode(std::string& str) {
    if (!(str.starts_with('"') && str.ends_with('"')))
        throw "Invalid input string";

    str = str.substr(1, str.length() - 2);
    std::string result;
    result.reserve(str.size()); // Reserve enough memory to avoid reallocations

    for (size_t i = 0; i < str.size(); ++i) {
        if (str[i] == '\\' && i + 1 < str.size()) {
            char next = str[i + 1];
            switch (next) {
                case 'n': result += '\n'; break;
                case 'r': result += '\r'; break;
                case 't': result += '\t'; break;
                case '\\': result += '\\'; break;
                case '"': result += '"'; break;
                case '\'': result += '\''; break;
                case '0': result += '\0'; break;
                default:
                    // Unknown escape: copy as-is
                    result += '\\';
                    result += next;
                    break;
            }
            ++i; // Skip the next character because it's part of escape
        } else {
            result += str[i];
        }
    }

    str = std::move(result); // Replace original string with decoded one
}

# ```
# 

```./vm/helpers/is_valid_identifier.cpp
#include <regex>
#include "is_valid_identifier.hpp"

bool is_valid_identifier(const std::string& s) {
    static const std::regex expr("^[a-zA-Z_][a-zA-Z_0-9]*$");
    return std::regex_match(s, expr);
}

# ```
# 

```./vm/helpers/parse_raw_bytecode.hpp
#pragma once
#include <vector>
#include <string>
#include "../core/Bytecode.hpp"

std::vector<Bytecode> parse_raw_bytecode(const std::string &input);

# ```
# 

```./vm/helpers/exec_step.hpp
#pragma once
#include <iostream>
#include "../core/Process.hpp"

void exec_step(Process&);

# ```
# 

```./vm/helpers/trim.cpp
#include "trim.hpp"
#include <string>

std::string trim(const std::string &s) {
    auto a = std::find_if_not(s.begin(), s.end(), [](char c){ return std::isspace(c); });
    auto b = std::find_if_not(s.rbegin(), s.rend(), [](char c){ return std::isspace(c); }).base();
    return (b <= a ? std::string() : std::string(a, b));
}

# ```
# 

```./vm/helpers/str_decode.hpp
#pragma once
#include <string>

/**
 * Decodes a given string modifying the original string
 * e.g. str_decode("\"hello\n world!\"") becomes;
 * "hello
 *   world!"
 */
void str_decode(std::string& str);

# ```
# 

```./vm/helpers/is_valid_identifier.hpp
#pragma once
#include <string>

bool is_valid_identifier(const std::string&);

# ```
# 

```./vm/helpers/parse_raw_bytecode.cpp
#include <iostream>
#include "parse_raw_bytecode.hpp"
#include <vector>
#include <string>
#include <sstream>
#include "../core/Bytecode.hpp"
#include "../core/opmap.hpp"
#include "trim.hpp"
#include "split.hpp"

std::vector<Bytecode> parse_raw_bytecode(const std::string &input) {
    std::vector<Bytecode> code;
    std::istringstream lines(input);
    std::string line;

    while (std::getline(lines, line)) {
        // remove comments
        line = trim(line);
        if (line.empty())
            continue;

        // function label
        if (line[0] == '.') {
            code.push_back({ OP_LABEL, { line } });
            continue;
        }

        // (OPCODE,arg1,arg2)
        if (line.front() == '(' && line.back() == ')') {
            auto inner = line.substr(1, line.size()-2);
            auto parts = split(inner, ',');
            auto it = opmap.find(parts[0]);
            if (it == opmap.end())
                throw std::runtime_error("Unknown opcode: " + parts[0]);
            Opcode opc = it->second;
            std::vector<std::string> args(parts.begin()+1, parts.end());
            code.push_back({ opc, args });
            continue;
        }

        throw std::runtime_error("Invalid line in bytecode: " + line);
    }

    return code;
}

# ```
# 

```./vm/helpers/parse_literal.cpp
#include "parse_literal.hpp"
#include <cctype> // for std::isdigit
#include <stdexcept>

std::shared_ptr<Object> parse_literal(const std::string& tok) {
    // --- Booleans ---
    if (tok == "true")  return std::make_shared<Boolean>(true);
    if (tok == "false") return std::make_shared<Boolean>(false);

    // --- Regular Expression Literals ---
    if (tok.size() >= 4 && tok[0] == 'r' && tok[1] == '/' && tok.find('/', 2) != std::string::npos) {
        auto lastSlash = tok.rfind('/');
        std::string pattern = tok.substr(2, lastSlash - 2);
        std::string flagsStr = tok.substr(lastSlash + 1);
        std::set<char> flags(flagsStr.begin(), flagsStr.end());
        return std::make_shared<RegEx>(pattern, flags);
    }

    // --- String Literals ---
    if (tok.size() >= 2 &&
        ((tok.front() == '"' && tok.back() == '"') ||
         (tok.front() == '\'' && tok.back() == '\''))) {
        std::string _tok = tok;
        str_decode(_tok);
        return std::make_shared<String>(_tok);
    }

    // --- Numeric Literals ---
    {
        size_t start = 0;
        if (tok[0] == '+' || tok[0] == '-') start = 1;

        bool hasDot = false;
        bool hasExp = false;
        for (size_t i = start; i < tok.size(); ++i) {
            if (tok[i] == '.') {
                if (hasDot) {
                    throw std::runtime_error("Invalid number: multiple dots in " + tok);
                }
                hasDot = true;
            }
            else if (tok[i] == 'e' || tok[i] == 'E') {
                if (hasExp) {
                    throw std::runtime_error("Invalid number: multiple exponents in " + tok);
                }
                hasExp = true;
            }
            else if (!std::isdigit(static_cast<unsigned char>(tok[i]))) {
                throw std::runtime_error("Invalid character '" + std::string(1, tok[i]) + "' in numeric literal: " + tok);
            }
        }

        try {
            if (hasExp) {
                double v = std::stod(tok);
                return std::make_shared<Scientific>(v);
            }
            if (hasDot) {
                double v = std::stod(tok);
                return std::make_shared<Decimal>(v);
            }
            int64_t v = std::stoll(tok);
            return std::make_shared<Integer>(v);
        }
        catch (const std::exception& e) {
            throw std::runtime_error("Failed to parse numeric literal: " + tok);
        }
    }

    throw std::runtime_error("Invalid literal: " + tok);
}

# ```
# 

```./vm/helpers/str_encode.hpp
#pragma once
#include <string>

/**
 * Encodes a given string modifying the original string
 * e.g. str_decode("\"hello\n world!\"") becomes;
 * \\"hello\\nworld!\\"
 */
void str_encode(std::string& str);

# ```
# 

```./vm/helpers/get_nanotime.cpp
#include <chrono>
#include "get_nanotime.hpp"

int64_t get_nanotime() {
    using namespace std::chrono;
    return duration_cast<nanoseconds>(
        high_resolution_clock::now().time_since_epoch()
    ).count();
}

# ```
# 

```./vm/helpers/unordered_map_to_string.hpp
#pragma once
#include <sstream>
#include <unordered_map>
#include <string>

template <typename K, typename V>
std::string unordered_map_to_string(const std::unordered_map<K, V>& umap);

# ```
# 

```./vm/helpers/split.hpp
#pragma once
#include <string>
#include <vector>

std::vector<std::string> split(const std::string &s, char d);

# ```
# 